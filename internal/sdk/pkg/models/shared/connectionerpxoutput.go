// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/etleap/terraform-provider-etleap/internal/sdk/pkg/utils"
	"time"
)

// ConnectionErpxStatus - The current status of the connection.
type ConnectionErpxStatus string

const (
	ConnectionErpxStatusUnknown     ConnectionErpxStatus = "UNKNOWN"
	ConnectionErpxStatusUp          ConnectionErpxStatus = "UP"
	ConnectionErpxStatusDown        ConnectionErpxStatus = "DOWN"
	ConnectionErpxStatusResize      ConnectionErpxStatus = "RESIZE"
	ConnectionErpxStatusMaintenance ConnectionErpxStatus = "MAINTENANCE"
	ConnectionErpxStatusQuota       ConnectionErpxStatus = "QUOTA"
	ConnectionErpxStatusCreating    ConnectionErpxStatus = "CREATING"
)

func (e ConnectionErpxStatus) ToPointer() *ConnectionErpxStatus {
	return &e
}

func (e *ConnectionErpxStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNKNOWN":
		fallthrough
	case "UP":
		fallthrough
	case "DOWN":
		fallthrough
	case "RESIZE":
		fallthrough
	case "MAINTENANCE":
		fallthrough
	case "QUOTA":
		fallthrough
	case "CREATING":
		*e = ConnectionErpxStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConnectionErpxStatus: %v", v)
	}
}

type ConnectionErpxDefaultUpdateSchedule struct {
	// The pipeline mode refers to how the pipeline fetches data changes from the source and how those changes are applied to the destination table. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjIyMjE3ODA2-introduction">the documentation</a> for more details.
	PipelineMode *PipelineUpdateModes `json:"pipelineMode,omitempty"`
	// The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information. When undefined, the pipeline will default to the schedule set on the source connection.
	UpdateSchedule *UpdateScheduleTypes `json:"updateSchedule,omitempty"`
}

func (o *ConnectionErpxDefaultUpdateSchedule) GetPipelineMode() *PipelineUpdateModes {
	if o == nil {
		return nil
	}
	return o.PipelineMode
}

func (o *ConnectionErpxDefaultUpdateSchedule) GetUpdateSchedule() *UpdateScheduleTypes {
	if o == nil {
		return nil
	}
	return o.UpdateSchedule
}

func (o *ConnectionErpxDefaultUpdateSchedule) GetUpdateScheduleMonthly() *UpdateScheduleModeMonthly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeMonthly
	}
	return nil
}

func (o *ConnectionErpxDefaultUpdateSchedule) GetUpdateScheduleHourly() *UpdateScheduleModeHourly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeHourly
	}
	return nil
}

func (o *ConnectionErpxDefaultUpdateSchedule) GetUpdateScheduleInterval() *UpdateScheduleModeInterval {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeInterval
	}
	return nil
}

func (o *ConnectionErpxDefaultUpdateSchedule) GetUpdateScheduleDaily() *UpdateScheduleModeDaily {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeDaily
	}
	return nil
}

func (o *ConnectionErpxDefaultUpdateSchedule) GetUpdateScheduleWeekly() *UpdateScheduleModeWeekly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeWeekly
	}
	return nil
}

type ConnectionErpxType string

const (
	ConnectionErpxTypeErpx ConnectionErpxType = "ERPX"
)

func (e ConnectionErpxType) ToPointer() *ConnectionErpxType {
	return &e
}

func (e *ConnectionErpxType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ERPX":
		*e = ConnectionErpxType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConnectionErpxType: %v", v)
	}
}

type ConnectionErpxOutput struct {
	// The current status of the connection.
	Status ConnectionErpxStatus `json:"status"`
	// The unique name of this connection.
	Name string `json:"name"`
	// The date and time when then the connection was created.
	CreateDate time.Time `json:"createDate"`
	// When an update schedule is not defined for a connection, the default schedule is used. The default defined individually per `pipelineMode` and may be subject to change.
	DefaultUpdateSchedule []ConnectionErpxDefaultUpdateSchedule `json:"defaultUpdateSchedule"`
	// Whether this connection has been marked as active.
	Active bool               `json:"active"`
	Type   ConnectionErpxType `json:"type"`
	// The unique identifier of the connection.
	ID string `json:"id"`
	// The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information. When undefined, the pipeline will default to the schedule set on the source connection.
	UpdateSchedule *UpdateScheduleTypes `json:"updateSchedule,omitempty"`
	// Your ERPx tenant authentication URL.
	TokenURL string `json:"tokenUrl"`
	// Client ID
	ClientID string `json:"clientId"`
	// Company IDs from which this connection will extract data, separated by commas. If not specified, Etleap will use the default ID linked to your user account. Please note that this field cannot be edited after the connection is created. Example: COMPANY1,COMPANY2
	CompanyIds *string `json:"companyIds,omitempty"`
	// Your ERPx tenant API URL.
	APIURL string `json:"apiUrl"`
}

func (c ConnectionErpxOutput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ConnectionErpxOutput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ConnectionErpxOutput) GetStatus() ConnectionErpxStatus {
	if o == nil {
		return ConnectionErpxStatus("")
	}
	return o.Status
}

func (o *ConnectionErpxOutput) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ConnectionErpxOutput) GetCreateDate() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreateDate
}

func (o *ConnectionErpxOutput) GetDefaultUpdateSchedule() []ConnectionErpxDefaultUpdateSchedule {
	if o == nil {
		return []ConnectionErpxDefaultUpdateSchedule{}
	}
	return o.DefaultUpdateSchedule
}

func (o *ConnectionErpxOutput) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *ConnectionErpxOutput) GetType() ConnectionErpxType {
	if o == nil {
		return ConnectionErpxType("")
	}
	return o.Type
}

func (o *ConnectionErpxOutput) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ConnectionErpxOutput) GetUpdateSchedule() *UpdateScheduleTypes {
	if o == nil {
		return nil
	}
	return o.UpdateSchedule
}

func (o *ConnectionErpxOutput) GetUpdateScheduleMonthly() *UpdateScheduleModeMonthly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeMonthly
	}
	return nil
}

func (o *ConnectionErpxOutput) GetUpdateScheduleHourly() *UpdateScheduleModeHourly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeHourly
	}
	return nil
}

func (o *ConnectionErpxOutput) GetUpdateScheduleInterval() *UpdateScheduleModeInterval {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeInterval
	}
	return nil
}

func (o *ConnectionErpxOutput) GetUpdateScheduleDaily() *UpdateScheduleModeDaily {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeDaily
	}
	return nil
}

func (o *ConnectionErpxOutput) GetUpdateScheduleWeekly() *UpdateScheduleModeWeekly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeWeekly
	}
	return nil
}

func (o *ConnectionErpxOutput) GetTokenURL() string {
	if o == nil {
		return ""
	}
	return o.TokenURL
}

func (o *ConnectionErpxOutput) GetClientID() string {
	if o == nil {
		return ""
	}
	return o.ClientID
}

func (o *ConnectionErpxOutput) GetCompanyIds() *string {
	if o == nil {
		return nil
	}
	return o.CompanyIds
}

func (o *ConnectionErpxOutput) GetAPIURL() string {
	if o == nil {
		return ""
	}
	return o.APIURL
}

type ConnectionErpx struct {
	// The unique name of this connection.
	Name string             `json:"name"`
	Type ConnectionErpxType `json:"type"`
	// The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information. When undefined, the pipeline will default to the schedule set on the source connection.
	UpdateSchedule *UpdateScheduleTypes `json:"updateSchedule,omitempty"`
	// Client Secret
	ClientSecret string `json:"clientSecret"`
	// Your ERPx tenant authentication URL.
	TokenURL string `json:"tokenUrl"`
	// Client ID
	ClientID string `json:"clientId"`
	// Company IDs from which this connection will extract data, separated by commas. If not specified, Etleap will use the default ID linked to your user account. Please note that this field cannot be edited after the connection is created. Example: COMPANY1,COMPANY2
	CompanyIds *string `json:"companyIds,omitempty"`
	// Your ERPx tenant API URL.
	APIURL string `json:"apiUrl"`
}

func (o *ConnectionErpx) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ConnectionErpx) GetType() ConnectionErpxType {
	if o == nil {
		return ConnectionErpxType("")
	}
	return o.Type
}

func (o *ConnectionErpx) GetUpdateSchedule() *UpdateScheduleTypes {
	if o == nil {
		return nil
	}
	return o.UpdateSchedule
}

func (o *ConnectionErpx) GetUpdateScheduleMonthly() *UpdateScheduleModeMonthly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeMonthly
	}
	return nil
}

func (o *ConnectionErpx) GetUpdateScheduleHourly() *UpdateScheduleModeHourly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeHourly
	}
	return nil
}

func (o *ConnectionErpx) GetUpdateScheduleInterval() *UpdateScheduleModeInterval {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeInterval
	}
	return nil
}

func (o *ConnectionErpx) GetUpdateScheduleDaily() *UpdateScheduleModeDaily {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeDaily
	}
	return nil
}

func (o *ConnectionErpx) GetUpdateScheduleWeekly() *UpdateScheduleModeWeekly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeWeekly
	}
	return nil
}

func (o *ConnectionErpx) GetClientSecret() string {
	if o == nil {
		return ""
	}
	return o.ClientSecret
}

func (o *ConnectionErpx) GetTokenURL() string {
	if o == nil {
		return ""
	}
	return o.TokenURL
}

func (o *ConnectionErpx) GetClientID() string {
	if o == nil {
		return ""
	}
	return o.ClientID
}

func (o *ConnectionErpx) GetCompanyIds() *string {
	if o == nil {
		return nil
	}
	return o.CompanyIds
}

func (o *ConnectionErpx) GetAPIURL() string {
	if o == nil {
		return ""
	}
	return o.APIURL
}
