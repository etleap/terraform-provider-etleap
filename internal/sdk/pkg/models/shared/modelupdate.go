// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/etleap/terraform-provider-etleap/internal/sdk/pkg/utils"
)

type ModelQueryAndTriggers struct {
	// The SQL query used to build this model. To specify dependencies on pipelines or other models, replace the schema and table name of the dependency with the id of the dependency enclosed in `{{` and `}}`. The dependency must load data into the same Etleap connection as the one given in `warehouse.connectionId` for this model.
	//
	// **For Example**
	// Say there is a pipeline with the id `abcd1234` which loads data to the table "schema"."my_table". To create a model in Etleap that has a dependency on this pipeline, the following query:
	//
	// ```sql
	// SELECT col1, col2 FROM "schema"."my_table";
	// ```
	//
	// becomes:
	// ```sql
	// SELECT col1, col2 FROM {{abcd1234}};
	// ```
	//
	// [See the Model documentation](https://docs.etleap.com/docs/documentation/ZG9jOjI0MzU2NDY3-introduction-to-models#model-dependencies) for more information on Model dependencies.
	Query string `json:"query"`
	// A list of model dependency ids. An update will be automatically triggered in this model if any of the dependencies listed here get new data. Any ids given here must be present as dependencies in the `query`.
	Triggers []string `json:"triggers"`
}

func (o *ModelQueryAndTriggers) GetQuery() string {
	if o == nil {
		return ""
	}
	return o.Query
}

func (o *ModelQueryAndTriggers) GetTriggers() []string {
	if o == nil {
		return []string{}
	}
	return o.Triggers
}

type RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode string

const (
	RefreshScheduleModeMonthlyScheduleTypesModelUpdateModeMonthly RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode = "MONTHLY"
)

func (e RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode) ToPointer() *RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode {
	return &e
}

func (e *RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MONTHLY":
		*e = RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode: %v", v)
	}
}

type ScheduleTypesMonthlyScheduleMode struct {
	Mode RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode `json:"mode"`
	// Day of the month this schedule should trigger at (in UTC).
	DayOfMonth int64 `json:"dayOfMonth"`
	// Hour of day this schedule should trigger at (in UTC).
	HourOfDay int64 `json:"hourOfDay"`
}

func (o *ScheduleTypesMonthlyScheduleMode) GetMode() RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode {
	if o == nil {
		return RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode("")
	}
	return o.Mode
}

func (o *ScheduleTypesMonthlyScheduleMode) GetDayOfMonth() int64 {
	if o == nil {
		return 0
	}
	return o.DayOfMonth
}

func (o *ScheduleTypesMonthlyScheduleMode) GetHourOfDay() int64 {
	if o == nil {
		return 0
	}
	return o.HourOfDay
}

type RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode string

const (
	RefreshScheduleModeWeeklyScheduleTypesModelUpdateModeWeekly RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode = "WEEKLY"
)

func (e RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode) ToPointer() *RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode {
	return &e
}

func (e *RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "WEEKLY":
		*e = RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode: %v", v)
	}
}

type ScheduleTypesWeeklyScheduleMode struct {
	Mode RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode `json:"mode"`
	// The day of the week this schedule should trigger at (in UTC).
	DayOfWeek int64 `json:"dayOfWeek"`
	// Hour of day this schedule should trigger at (in UTC).
	HourOfDay int64 `json:"hourOfDay"`
}

func (o *ScheduleTypesWeeklyScheduleMode) GetMode() RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode {
	if o == nil {
		return RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode("")
	}
	return o.Mode
}

func (o *ScheduleTypesWeeklyScheduleMode) GetDayOfWeek() int64 {
	if o == nil {
		return 0
	}
	return o.DayOfWeek
}

func (o *ScheduleTypesWeeklyScheduleMode) GetHourOfDay() int64 {
	if o == nil {
		return 0
	}
	return o.HourOfDay
}

type RefreshScheduleModeDailyScheduleTypesModelUpdateMode string

const (
	RefreshScheduleModeDailyScheduleTypesModelUpdateModeDaily RefreshScheduleModeDailyScheduleTypesModelUpdateMode = "DAILY"
)

func (e RefreshScheduleModeDailyScheduleTypesModelUpdateMode) ToPointer() *RefreshScheduleModeDailyScheduleTypesModelUpdateMode {
	return &e
}

func (e *RefreshScheduleModeDailyScheduleTypesModelUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DAILY":
		*e = RefreshScheduleModeDailyScheduleTypesModelUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeDailyScheduleTypesModelUpdateMode: %v", v)
	}
}

type ScheduleTypesDailyScheduleMode struct {
	Mode RefreshScheduleModeDailyScheduleTypesModelUpdateMode `json:"mode"`
	// Hour of day this schedule should trigger at (in UTC).
	HourOfDay int64 `json:"hourOfDay"`
}

func (o *ScheduleTypesDailyScheduleMode) GetMode() RefreshScheduleModeDailyScheduleTypesModelUpdateMode {
	if o == nil {
		return RefreshScheduleModeDailyScheduleTypesModelUpdateMode("")
	}
	return o.Mode
}

func (o *ScheduleTypesDailyScheduleMode) GetHourOfDay() int64 {
	if o == nil {
		return 0
	}
	return o.HourOfDay
}

type RefreshScheduleModeHourlyScheduleTypesModelUpdateMode string

const (
	RefreshScheduleModeHourlyScheduleTypesModelUpdateModeHourly RefreshScheduleModeHourlyScheduleTypesModelUpdateMode = "HOURLY"
)

func (e RefreshScheduleModeHourlyScheduleTypesModelUpdateMode) ToPointer() *RefreshScheduleModeHourlyScheduleTypesModelUpdateMode {
	return &e
}

func (e *RefreshScheduleModeHourlyScheduleTypesModelUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HOURLY":
		*e = RefreshScheduleModeHourlyScheduleTypesModelUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeHourlyScheduleTypesModelUpdateMode: %v", v)
	}
}

type ScheduleTypesHourlyScheduleMode struct {
	Mode RefreshScheduleModeHourlyScheduleTypesModelUpdateMode `json:"mode"`
}

func (o *ScheduleTypesHourlyScheduleMode) GetMode() RefreshScheduleModeHourlyScheduleTypesModelUpdateMode {
	if o == nil {
		return RefreshScheduleModeHourlyScheduleTypesModelUpdateMode("")
	}
	return o.Mode
}

type RefreshScheduleModeNeverScheduleTypesMode string

const (
	RefreshScheduleModeNeverScheduleTypesModeNever RefreshScheduleModeNeverScheduleTypesMode = "NEVER"
)

func (e RefreshScheduleModeNeverScheduleTypesMode) ToPointer() *RefreshScheduleModeNeverScheduleTypesMode {
	return &e
}

func (e *RefreshScheduleModeNeverScheduleTypesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NEVER":
		*e = RefreshScheduleModeNeverScheduleTypesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeNeverScheduleTypesMode: %v", v)
	}
}

type ScheduleTypesNeverScheduleMode struct {
	Mode RefreshScheduleModeNeverScheduleTypesMode `json:"mode"`
}

func (o *ScheduleTypesNeverScheduleMode) GetMode() RefreshScheduleModeNeverScheduleTypesMode {
	if o == nil {
		return RefreshScheduleModeNeverScheduleTypesMode("")
	}
	return o.Mode
}

type ModelUpdateScheduleTypesType string

const (
	ModelUpdateScheduleTypesTypeNever   ModelUpdateScheduleTypesType = "NEVER"
	ModelUpdateScheduleTypesTypeHourly  ModelUpdateScheduleTypesType = "HOURLY"
	ModelUpdateScheduleTypesTypeDaily   ModelUpdateScheduleTypesType = "DAILY"
	ModelUpdateScheduleTypesTypeWeekly  ModelUpdateScheduleTypesType = "WEEKLY"
	ModelUpdateScheduleTypesTypeMonthly ModelUpdateScheduleTypesType = "MONTHLY"
)

// ModelUpdateScheduleTypes - How often this model should update. Etleap will periodically update the model table in your warehouse according to this schedule. See [the Model Updates documentation](https://docs.etleap.com/docs/documentation/ZG9jOjI0MzU2NDY3-introduction-to-models#model-updates) for more information.
type ModelUpdateScheduleTypes struct {
	ScheduleTypesNeverScheduleMode   *ScheduleTypesNeverScheduleMode
	ScheduleTypesHourlyScheduleMode  *ScheduleTypesHourlyScheduleMode
	ScheduleTypesDailyScheduleMode   *ScheduleTypesDailyScheduleMode
	ScheduleTypesWeeklyScheduleMode  *ScheduleTypesWeeklyScheduleMode
	ScheduleTypesMonthlyScheduleMode *ScheduleTypesMonthlyScheduleMode

	Type ModelUpdateScheduleTypesType
}

func CreateModelUpdateScheduleTypesNever(never ScheduleTypesNeverScheduleMode) ModelUpdateScheduleTypes {
	typ := ModelUpdateScheduleTypesTypeNever

	typStr := RefreshScheduleModeNeverScheduleTypesMode(typ)
	never.Mode = typStr

	return ModelUpdateScheduleTypes{
		ScheduleTypesNeverScheduleMode: &never,
		Type:                           typ,
	}
}

func CreateModelUpdateScheduleTypesHourly(hourly ScheduleTypesHourlyScheduleMode) ModelUpdateScheduleTypes {
	typ := ModelUpdateScheduleTypesTypeHourly

	typStr := RefreshScheduleModeHourlyScheduleTypesModelUpdateMode(typ)
	hourly.Mode = typStr

	return ModelUpdateScheduleTypes{
		ScheduleTypesHourlyScheduleMode: &hourly,
		Type:                            typ,
	}
}

func CreateModelUpdateScheduleTypesDaily(daily ScheduleTypesDailyScheduleMode) ModelUpdateScheduleTypes {
	typ := ModelUpdateScheduleTypesTypeDaily

	typStr := RefreshScheduleModeDailyScheduleTypesModelUpdateMode(typ)
	daily.Mode = typStr

	return ModelUpdateScheduleTypes{
		ScheduleTypesDailyScheduleMode: &daily,
		Type:                           typ,
	}
}

func CreateModelUpdateScheduleTypesWeekly(weekly ScheduleTypesWeeklyScheduleMode) ModelUpdateScheduleTypes {
	typ := ModelUpdateScheduleTypesTypeWeekly

	typStr := RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode(typ)
	weekly.Mode = typStr

	return ModelUpdateScheduleTypes{
		ScheduleTypesWeeklyScheduleMode: &weekly,
		Type:                            typ,
	}
}

func CreateModelUpdateScheduleTypesMonthly(monthly ScheduleTypesMonthlyScheduleMode) ModelUpdateScheduleTypes {
	typ := ModelUpdateScheduleTypesTypeMonthly

	typStr := RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode(typ)
	monthly.Mode = typStr

	return ModelUpdateScheduleTypes{
		ScheduleTypesMonthlyScheduleMode: &monthly,
		Type:                             typ,
	}
}

func (u *ModelUpdateScheduleTypes) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Mode string
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Mode {
	case "NEVER":
		scheduleTypesNeverScheduleMode := new(ScheduleTypesNeverScheduleMode)
		if err := utils.UnmarshalJSON(data, &scheduleTypesNeverScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.ScheduleTypesNeverScheduleMode = scheduleTypesNeverScheduleMode
		u.Type = ModelUpdateScheduleTypesTypeNever
		return nil
	case "HOURLY":
		scheduleTypesHourlyScheduleMode := new(ScheduleTypesHourlyScheduleMode)
		if err := utils.UnmarshalJSON(data, &scheduleTypesHourlyScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.ScheduleTypesHourlyScheduleMode = scheduleTypesHourlyScheduleMode
		u.Type = ModelUpdateScheduleTypesTypeHourly
		return nil
	case "DAILY":
		scheduleTypesDailyScheduleMode := new(ScheduleTypesDailyScheduleMode)
		if err := utils.UnmarshalJSON(data, &scheduleTypesDailyScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.ScheduleTypesDailyScheduleMode = scheduleTypesDailyScheduleMode
		u.Type = ModelUpdateScheduleTypesTypeDaily
		return nil
	case "WEEKLY":
		scheduleTypesWeeklyScheduleMode := new(ScheduleTypesWeeklyScheduleMode)
		if err := utils.UnmarshalJSON(data, &scheduleTypesWeeklyScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.ScheduleTypesWeeklyScheduleMode = scheduleTypesWeeklyScheduleMode
		u.Type = ModelUpdateScheduleTypesTypeWeekly
		return nil
	case "MONTHLY":
		scheduleTypesMonthlyScheduleMode := new(ScheduleTypesMonthlyScheduleMode)
		if err := utils.UnmarshalJSON(data, &scheduleTypesMonthlyScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.ScheduleTypesMonthlyScheduleMode = scheduleTypesMonthlyScheduleMode
		u.Type = ModelUpdateScheduleTypesTypeMonthly
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u ModelUpdateScheduleTypes) MarshalJSON() ([]byte, error) {
	if u.ScheduleTypesNeverScheduleMode != nil {
		return utils.MarshalJSON(u.ScheduleTypesNeverScheduleMode, "", true)
	}

	if u.ScheduleTypesHourlyScheduleMode != nil {
		return utils.MarshalJSON(u.ScheduleTypesHourlyScheduleMode, "", true)
	}

	if u.ScheduleTypesDailyScheduleMode != nil {
		return utils.MarshalJSON(u.ScheduleTypesDailyScheduleMode, "", true)
	}

	if u.ScheduleTypesWeeklyScheduleMode != nil {
		return utils.MarshalJSON(u.ScheduleTypesWeeklyScheduleMode, "", true)
	}

	if u.ScheduleTypesMonthlyScheduleMode != nil {
		return utils.MarshalJSON(u.ScheduleTypesMonthlyScheduleMode, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// ModelUpdate - The response body for PATCH /models
//
// <!-- theme: warning -->
// > This feature is currently in Beta which means that it is subject to non-backwards-compatible and breaking changes.
type ModelUpdate struct {
	Name             *string                `json:"name,omitempty"`
	Paused           *bool                  `json:"paused,omitempty"`
	Warehouse        *WarehouseUpdateTypes  `json:"warehouse,omitempty"`
	QueryAndTriggers *ModelQueryAndTriggers `json:"queryAndTriggers,omitempty"`
	// How often this model should update. Etleap will periodically update the model table in your warehouse according to this schedule. See [the Model Updates documentation](https://docs.etleap.com/docs/documentation/ZG9jOjI0MzU2NDY3-introduction-to-models#model-updates) for more information.
	UpdateSchedule *ModelUpdateScheduleTypes `json:"updateSchedule,omitempty"`
	// A list of users' email to share the model with.
	//
	// A model cannot be unshared; therefore future calls can only add to this list.
	//
	// Deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
	Shares []string `json:"shares,omitempty"`
}

func (o *ModelUpdate) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *ModelUpdate) GetPaused() *bool {
	if o == nil {
		return nil
	}
	return o.Paused
}

func (o *ModelUpdate) GetWarehouse() *WarehouseUpdateTypes {
	if o == nil {
		return nil
	}
	return o.Warehouse
}

func (o *ModelUpdate) GetWarehouseRedshift() *WarehouseRedshiftUpdate {
	if v := o.GetWarehouse(); v != nil {
		return v.WarehouseRedshiftUpdate
	}
	return nil
}

func (o *ModelUpdate) GetWarehouseSnowflake() *WarehouseSnowflakeUpdate {
	if v := o.GetWarehouse(); v != nil {
		return v.WarehouseSnowflakeUpdate
	}
	return nil
}

func (o *ModelUpdate) GetQueryAndTriggers() *ModelQueryAndTriggers {
	if o == nil {
		return nil
	}
	return o.QueryAndTriggers
}

func (o *ModelUpdate) GetUpdateSchedule() *ModelUpdateScheduleTypes {
	if o == nil {
		return nil
	}
	return o.UpdateSchedule
}

func (o *ModelUpdate) GetUpdateScheduleNever() *ScheduleTypesNeverScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.ScheduleTypesNeverScheduleMode
	}
	return nil
}

func (o *ModelUpdate) GetUpdateScheduleHourly() *ScheduleTypesHourlyScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.ScheduleTypesHourlyScheduleMode
	}
	return nil
}

func (o *ModelUpdate) GetUpdateScheduleDaily() *ScheduleTypesDailyScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.ScheduleTypesDailyScheduleMode
	}
	return nil
}

func (o *ModelUpdate) GetUpdateScheduleWeekly() *ScheduleTypesWeeklyScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.ScheduleTypesWeeklyScheduleMode
	}
	return nil
}

func (o *ModelUpdate) GetUpdateScheduleMonthly() *ScheduleTypesMonthlyScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.ScheduleTypesMonthlyScheduleMode
	}
	return nil
}

func (o *ModelUpdate) GetShares() []string {
	if o == nil {
		return nil
	}
	return o.Shares
}
