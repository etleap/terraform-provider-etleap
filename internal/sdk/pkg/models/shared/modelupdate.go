// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/etleap/terraform-provider-etleap/internal/sdk/pkg/utils"
)

type ModelQueryAndTriggers struct {
	// The SQL query used to build this model. To specify dependencies on pipelines or other models, replace the schema and table name of the dependency with the id of the dependency enclosed in `{{` and `}}`. The dependency must load data into the same Etleap connection as the one given in `warehouse.connectionId` for this model.
	//
	// **For Example**
	// Say there is a pipeline with the id `abcd1234` which loads data to the table "schema"."my_table". To create a model in Etleap that has a dependency on this pipeline, the following query:
	//
	// ```sql
	// SELECT col1, col2 FROM "schema"."my_table";
	// ```
	//
	// becomes:
	// ```sql
	// SELECT col1, col2 FROM {{abcd1234}};
	// ```
	//
	// [See the Model documentation](https://docs.etleap.com/docs/documentation/ZG9jOjI0MzU2NDY3-introduction-to-models#model-dependencies) for more information on Model dependencies.
	Query string `json:"query"`
	// A list of model dependency ids. An update will be automatically triggered in this model if any of the dependencies listed here get new data. Any ids given here must be present as dependencies in the `query`.
	Triggers []string `json:"triggers"`
}

func (o *ModelQueryAndTriggers) GetQuery() string {
	if o == nil {
		return ""
	}
	return o.Query
}

func (o *ModelQueryAndTriggers) GetTriggers() []string {
	if o == nil {
		return []string{}
	}
	return o.Triggers
}

type RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode string

const (
	RefreshScheduleModeMonthlyScheduleTypesModelUpdateModeMonthly RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode = "MONTHLY"
)

func (e RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode) ToPointer() *RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode {
	return &e
}

func (e *RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MONTHLY":
		*e = RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode: %v", v)
	}
}

type RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode struct {
	Mode RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode `json:"mode"`
	// Day of the month this schedule should trigger at (in UTC).
	DayOfMonth int64 `json:"dayOfMonth"`
	// Hour of day this schedule should trigger at (in UTC).
	HourOfDay int64 `json:"hourOfDay"`
}

func (o *RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode) GetMode() RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode {
	if o == nil {
		return RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode("")
	}
	return o.Mode
}

func (o *RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode) GetDayOfMonth() int64 {
	if o == nil {
		return 0
	}
	return o.DayOfMonth
}

func (o *RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode) GetHourOfDay() int64 {
	if o == nil {
		return 0
	}
	return o.HourOfDay
}

type RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode string

const (
	RefreshScheduleModeWeeklyScheduleTypesModelUpdateModeWeekly RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode = "WEEKLY"
)

func (e RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode) ToPointer() *RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode {
	return &e
}

func (e *RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "WEEKLY":
		*e = RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode: %v", v)
	}
}

type RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode struct {
	Mode RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode `json:"mode"`
	// The day of the week this schedule should trigger at (in UTC).
	DayOfWeek int64 `json:"dayOfWeek"`
	// Hour of day this schedule should trigger at (in UTC).
	HourOfDay int64 `json:"hourOfDay"`
}

func (o *RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode) GetMode() RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode {
	if o == nil {
		return RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode("")
	}
	return o.Mode
}

func (o *RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode) GetDayOfWeek() int64 {
	if o == nil {
		return 0
	}
	return o.DayOfWeek
}

func (o *RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode) GetHourOfDay() int64 {
	if o == nil {
		return 0
	}
	return o.HourOfDay
}

type RefreshScheduleModeDailyScheduleTypesModelUpdateMode string

const (
	RefreshScheduleModeDailyScheduleTypesModelUpdateModeDaily RefreshScheduleModeDailyScheduleTypesModelUpdateMode = "DAILY"
)

func (e RefreshScheduleModeDailyScheduleTypesModelUpdateMode) ToPointer() *RefreshScheduleModeDailyScheduleTypesModelUpdateMode {
	return &e
}

func (e *RefreshScheduleModeDailyScheduleTypesModelUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DAILY":
		*e = RefreshScheduleModeDailyScheduleTypesModelUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeDailyScheduleTypesModelUpdateMode: %v", v)
	}
}

type RefreshScheduleModeDailyScheduleTypesDailyScheduleMode struct {
	Mode RefreshScheduleModeDailyScheduleTypesModelUpdateMode `json:"mode"`
	// Hour of day this schedule should trigger at (in UTC).
	HourOfDay int64 `json:"hourOfDay"`
}

func (o *RefreshScheduleModeDailyScheduleTypesDailyScheduleMode) GetMode() RefreshScheduleModeDailyScheduleTypesModelUpdateMode {
	if o == nil {
		return RefreshScheduleModeDailyScheduleTypesModelUpdateMode("")
	}
	return o.Mode
}

func (o *RefreshScheduleModeDailyScheduleTypesDailyScheduleMode) GetHourOfDay() int64 {
	if o == nil {
		return 0
	}
	return o.HourOfDay
}

type RefreshScheduleModeHourlyScheduleTypesModelUpdateMode string

const (
	RefreshScheduleModeHourlyScheduleTypesModelUpdateModeHourly RefreshScheduleModeHourlyScheduleTypesModelUpdateMode = "HOURLY"
)

func (e RefreshScheduleModeHourlyScheduleTypesModelUpdateMode) ToPointer() *RefreshScheduleModeHourlyScheduleTypesModelUpdateMode {
	return &e
}

func (e *RefreshScheduleModeHourlyScheduleTypesModelUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HOURLY":
		*e = RefreshScheduleModeHourlyScheduleTypesModelUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeHourlyScheduleTypesModelUpdateMode: %v", v)
	}
}

type RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode struct {
	Mode RefreshScheduleModeHourlyScheduleTypesModelUpdateMode `json:"mode"`
}

func (o *RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode) GetMode() RefreshScheduleModeHourlyScheduleTypesModelUpdateMode {
	if o == nil {
		return RefreshScheduleModeHourlyScheduleTypesModelUpdateMode("")
	}
	return o.Mode
}

type RefreshScheduleModeNeverScheduleTypesModelUpdateMode string

const (
	RefreshScheduleModeNeverScheduleTypesModelUpdateModeNever RefreshScheduleModeNeverScheduleTypesModelUpdateMode = "NEVER"
)

func (e RefreshScheduleModeNeverScheduleTypesModelUpdateMode) ToPointer() *RefreshScheduleModeNeverScheduleTypesModelUpdateMode {
	return &e
}

func (e *RefreshScheduleModeNeverScheduleTypesModelUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NEVER":
		*e = RefreshScheduleModeNeverScheduleTypesModelUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeNeverScheduleTypesModelUpdateMode: %v", v)
	}
}

type RefreshScheduleModeNeverScheduleTypesNeverScheduleMode struct {
	Mode RefreshScheduleModeNeverScheduleTypesModelUpdateMode `json:"mode"`
}

func (o *RefreshScheduleModeNeverScheduleTypesNeverScheduleMode) GetMode() RefreshScheduleModeNeverScheduleTypesModelUpdateMode {
	if o == nil {
		return RefreshScheduleModeNeverScheduleTypesModelUpdateMode("")
	}
	return o.Mode
}

type ModelUpdateScheduleTypesType string

const (
	ModelUpdateScheduleTypesTypeNever   ModelUpdateScheduleTypesType = "NEVER"
	ModelUpdateScheduleTypesTypeHourly  ModelUpdateScheduleTypesType = "HOURLY"
	ModelUpdateScheduleTypesTypeDaily   ModelUpdateScheduleTypesType = "DAILY"
	ModelUpdateScheduleTypesTypeWeekly  ModelUpdateScheduleTypesType = "WEEKLY"
	ModelUpdateScheduleTypesTypeMonthly ModelUpdateScheduleTypesType = "MONTHLY"
)

// ModelUpdateScheduleTypes - How often this model should update. Etleap will periodically update the model table in your warehouse according to this schedule. See [the Model Updates documentation](https://docs.etleap.com/docs/documentation/ZG9jOjI0MzU2NDY3-introduction-to-models#model-updates) for more information.
type ModelUpdateScheduleTypes struct {
	RefreshScheduleModeNeverScheduleTypesNeverScheduleMode     *RefreshScheduleModeNeverScheduleTypesNeverScheduleMode
	RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode   *RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode
	RefreshScheduleModeDailyScheduleTypesDailyScheduleMode     *RefreshScheduleModeDailyScheduleTypesDailyScheduleMode
	RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode   *RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode
	RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode *RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode

	Type ModelUpdateScheduleTypesType
}

func CreateModelUpdateScheduleTypesNever(never RefreshScheduleModeNeverScheduleTypesNeverScheduleMode) ModelUpdateScheduleTypes {
	typ := ModelUpdateScheduleTypesTypeNever

	typStr := RefreshScheduleModeNeverScheduleTypesModelUpdateMode(typ)
	never.Mode = typStr

	return ModelUpdateScheduleTypes{
		RefreshScheduleModeNeverScheduleTypesNeverScheduleMode: &never,
		Type: typ,
	}
}

func CreateModelUpdateScheduleTypesHourly(hourly RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode) ModelUpdateScheduleTypes {
	typ := ModelUpdateScheduleTypesTypeHourly

	typStr := RefreshScheduleModeHourlyScheduleTypesModelUpdateMode(typ)
	hourly.Mode = typStr

	return ModelUpdateScheduleTypes{
		RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode: &hourly,
		Type: typ,
	}
}

func CreateModelUpdateScheduleTypesDaily(daily RefreshScheduleModeDailyScheduleTypesDailyScheduleMode) ModelUpdateScheduleTypes {
	typ := ModelUpdateScheduleTypesTypeDaily

	typStr := RefreshScheduleModeDailyScheduleTypesModelUpdateMode(typ)
	daily.Mode = typStr

	return ModelUpdateScheduleTypes{
		RefreshScheduleModeDailyScheduleTypesDailyScheduleMode: &daily,
		Type: typ,
	}
}

func CreateModelUpdateScheduleTypesWeekly(weekly RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode) ModelUpdateScheduleTypes {
	typ := ModelUpdateScheduleTypesTypeWeekly

	typStr := RefreshScheduleModeWeeklyScheduleTypesModelUpdateMode(typ)
	weekly.Mode = typStr

	return ModelUpdateScheduleTypes{
		RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode: &weekly,
		Type: typ,
	}
}

func CreateModelUpdateScheduleTypesMonthly(monthly RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode) ModelUpdateScheduleTypes {
	typ := ModelUpdateScheduleTypesTypeMonthly

	typStr := RefreshScheduleModeMonthlyScheduleTypesModelUpdateMode(typ)
	monthly.Mode = typStr

	return ModelUpdateScheduleTypes{
		RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode: &monthly,
		Type: typ,
	}
}

func (u *ModelUpdateScheduleTypes) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Mode string
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Mode {
	case "NEVER":
		refreshScheduleModeNeverScheduleTypesNeverScheduleMode := new(RefreshScheduleModeNeverScheduleTypesNeverScheduleMode)
		if err := utils.UnmarshalJSON(data, &refreshScheduleModeNeverScheduleTypesNeverScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.RefreshScheduleModeNeverScheduleTypesNeverScheduleMode = refreshScheduleModeNeverScheduleTypesNeverScheduleMode
		u.Type = ModelUpdateScheduleTypesTypeNever
		return nil
	case "HOURLY":
		refreshScheduleModeHourlyScheduleTypesHourlyScheduleMode := new(RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode)
		if err := utils.UnmarshalJSON(data, &refreshScheduleModeHourlyScheduleTypesHourlyScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode = refreshScheduleModeHourlyScheduleTypesHourlyScheduleMode
		u.Type = ModelUpdateScheduleTypesTypeHourly
		return nil
	case "DAILY":
		refreshScheduleModeDailyScheduleTypesDailyScheduleMode := new(RefreshScheduleModeDailyScheduleTypesDailyScheduleMode)
		if err := utils.UnmarshalJSON(data, &refreshScheduleModeDailyScheduleTypesDailyScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.RefreshScheduleModeDailyScheduleTypesDailyScheduleMode = refreshScheduleModeDailyScheduleTypesDailyScheduleMode
		u.Type = ModelUpdateScheduleTypesTypeDaily
		return nil
	case "WEEKLY":
		refreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode := new(RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode)
		if err := utils.UnmarshalJSON(data, &refreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode = refreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode
		u.Type = ModelUpdateScheduleTypesTypeWeekly
		return nil
	case "MONTHLY":
		refreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode := new(RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode)
		if err := utils.UnmarshalJSON(data, &refreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode = refreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode
		u.Type = ModelUpdateScheduleTypesTypeMonthly
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u ModelUpdateScheduleTypes) MarshalJSON() ([]byte, error) {
	if u.RefreshScheduleModeNeverScheduleTypesNeverScheduleMode != nil {
		return utils.MarshalJSON(u.RefreshScheduleModeNeverScheduleTypesNeverScheduleMode, "", true)
	}

	if u.RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode != nil {
		return utils.MarshalJSON(u.RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode, "", true)
	}

	if u.RefreshScheduleModeDailyScheduleTypesDailyScheduleMode != nil {
		return utils.MarshalJSON(u.RefreshScheduleModeDailyScheduleTypesDailyScheduleMode, "", true)
	}

	if u.RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode != nil {
		return utils.MarshalJSON(u.RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode, "", true)
	}

	if u.RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode != nil {
		return utils.MarshalJSON(u.RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// ModelUpdate - The response body for PATCH /models.
type ModelUpdate struct {
	Name             *string                `json:"name,omitempty"`
	Paused           *bool                  `json:"paused,omitempty"`
	Warehouse        *WarehouseUpdateTypes  `json:"warehouse,omitempty"`
	QueryAndTriggers *ModelQueryAndTriggers `json:"queryAndTriggers,omitempty"`
	// How often this model should update. Etleap will periodically update the model table in your warehouse according to this schedule. See [the Model Updates documentation](https://docs.etleap.com/docs/documentation/ZG9jOjI0MzU2NDY3-introduction-to-models#model-updates) for more information.
	UpdateSchedule *ModelUpdateScheduleTypes `json:"updateSchedule,omitempty"`
	// A list of users' email to share the model with.
	//
	// A model cannot be unshared; therefore future calls can only add to this list.
	//
	// Deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
	Shares []string `json:"shares,omitempty"`
}

func (o *ModelUpdate) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *ModelUpdate) GetPaused() *bool {
	if o == nil {
		return nil
	}
	return o.Paused
}

func (o *ModelUpdate) GetWarehouse() *WarehouseUpdateTypes {
	if o == nil {
		return nil
	}
	return o.Warehouse
}

func (o *ModelUpdate) GetWarehouseRedshift() *WarehouseRedshiftUpdate {
	if v := o.GetWarehouse(); v != nil {
		return v.WarehouseRedshiftUpdate
	}
	return nil
}

func (o *ModelUpdate) GetWarehouseSnowflake() *WarehouseSnowflakeUpdate {
	if v := o.GetWarehouse(); v != nil {
		return v.WarehouseSnowflakeUpdate
	}
	return nil
}

func (o *ModelUpdate) GetQueryAndTriggers() *ModelQueryAndTriggers {
	if o == nil {
		return nil
	}
	return o.QueryAndTriggers
}

func (o *ModelUpdate) GetUpdateSchedule() *ModelUpdateScheduleTypes {
	if o == nil {
		return nil
	}
	return o.UpdateSchedule
}

func (o *ModelUpdate) GetUpdateScheduleNever() *RefreshScheduleModeNeverScheduleTypesNeverScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.RefreshScheduleModeNeverScheduleTypesNeverScheduleMode
	}
	return nil
}

func (o *ModelUpdate) GetUpdateScheduleHourly() *RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode
	}
	return nil
}

func (o *ModelUpdate) GetUpdateScheduleDaily() *RefreshScheduleModeDailyScheduleTypesDailyScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.RefreshScheduleModeDailyScheduleTypesDailyScheduleMode
	}
	return nil
}

func (o *ModelUpdate) GetUpdateScheduleWeekly() *RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode
	}
	return nil
}

func (o *ModelUpdate) GetUpdateScheduleMonthly() *RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode
	}
	return nil
}

func (o *ModelUpdate) GetShares() []string {
	if o == nil {
		return nil
	}
	return o.Shares
}
