// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/etleap/terraform-provider-etleap/internal/sdk/pkg/utils"
	"time"
)

type ConnectionTwitterType string

const (
	ConnectionTwitterTypeTwitterAds ConnectionTwitterType = "TWITTER_ADS"
)

func (e ConnectionTwitterType) ToPointer() *ConnectionTwitterType {
	return &e
}

func (e *ConnectionTwitterType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TWITTER_ADS":
		*e = ConnectionTwitterType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConnectionTwitterType: %v", v)
	}
}

// ConnectionTwitterStatus - The current status of the connection.
type ConnectionTwitterStatus string

const (
	ConnectionTwitterStatusUnknown     ConnectionTwitterStatus = "UNKNOWN"
	ConnectionTwitterStatusUp          ConnectionTwitterStatus = "UP"
	ConnectionTwitterStatusDown        ConnectionTwitterStatus = "DOWN"
	ConnectionTwitterStatusResize      ConnectionTwitterStatus = "RESIZE"
	ConnectionTwitterStatusMaintenance ConnectionTwitterStatus = "MAINTENANCE"
	ConnectionTwitterStatusQuota       ConnectionTwitterStatus = "QUOTA"
	ConnectionTwitterStatusCreating    ConnectionTwitterStatus = "CREATING"
)

func (e ConnectionTwitterStatus) ToPointer() *ConnectionTwitterStatus {
	return &e
}

func (e *ConnectionTwitterStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNKNOWN":
		fallthrough
	case "UP":
		fallthrough
	case "DOWN":
		fallthrough
	case "RESIZE":
		fallthrough
	case "MAINTENANCE":
		fallthrough
	case "QUOTA":
		fallthrough
	case "CREATING":
		*e = ConnectionTwitterStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConnectionTwitterStatus: %v", v)
	}
}

type ConnectionTwitterDefaultUpdateSchedule struct {
	// The pipeline mode refers to how the pipeline fetches data changes from the source and how those changes are applied to the destination table. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjIyMjE3ODA2-introduction">the documentation</a> for more details.
	PipelineMode *PipelineUpdateModes `json:"pipelineMode,omitempty"`
	// The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information. When undefined, the pipeline will default to the schedule set on the source connection.
	UpdateSchedule *UpdateScheduleTypes `json:"updateSchedule,omitempty"`
}

func (o *ConnectionTwitterDefaultUpdateSchedule) GetPipelineMode() *PipelineUpdateModes {
	if o == nil {
		return nil
	}
	return o.PipelineMode
}

func (o *ConnectionTwitterDefaultUpdateSchedule) GetUpdateSchedule() *UpdateScheduleTypes {
	if o == nil {
		return nil
	}
	return o.UpdateSchedule
}

func (o *ConnectionTwitterDefaultUpdateSchedule) GetUpdateScheduleInterval() *UpdateScheduleModeInterval {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeInterval
	}
	return nil
}

func (o *ConnectionTwitterDefaultUpdateSchedule) GetUpdateScheduleHourly() *UpdateScheduleModeHourly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeHourly
	}
	return nil
}

func (o *ConnectionTwitterDefaultUpdateSchedule) GetUpdateScheduleDaily() *UpdateScheduleModeDaily {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeDaily
	}
	return nil
}

func (o *ConnectionTwitterDefaultUpdateSchedule) GetUpdateScheduleWeekly() *UpdateScheduleModeWeekly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeWeekly
	}
	return nil
}

func (o *ConnectionTwitterDefaultUpdateSchedule) GetUpdateScheduleMonthly() *UpdateScheduleModeMonthly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeMonthly
	}
	return nil
}

type ConnectionTwitter struct {
	// The unique identifier of the connection.
	ID string `json:"id"`
	// The unique name of this connection.
	Name string                `json:"name"`
	Type ConnectionTwitterType `json:"type"`
	// Whether this connection has been marked as active.
	Active bool `json:"active"`
	// The current status of the connection.
	Status ConnectionTwitterStatus `json:"status"`
	// The date and time when then the connection was created.
	CreateDate time.Time `json:"createDate"`
	// The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information. When undefined, the pipeline will default to the schedule set on the source connection.
	UpdateSchedule *UpdateScheduleTypes `json:"updateSchedule,omitempty"`
	// When an update schedule is not defined for a connection, the default schedule is used. The default defined individually per `pipelineMode` and may be subject to change.
	DefaultUpdateSchedule []ConnectionTwitterDefaultUpdateSchedule `json:"defaultUpdateSchedule"`
	// This represents your Twitter developer app when making API requests. Generated under 'Consumer API keys'.
	AppKey string `json:"appKey"`
	// If you want to create pipelines from entities that uses Twitter API V2 endpoints you need to specify which Twitter accounts you want to retrieve data from. The usernames must be separated by comma and without the @
	TwitterUsernames *string `json:"twitterUsernames,omitempty"`
}

func (c ConnectionTwitter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ConnectionTwitter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ConnectionTwitter) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ConnectionTwitter) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ConnectionTwitter) GetType() ConnectionTwitterType {
	if o == nil {
		return ConnectionTwitterType("")
	}
	return o.Type
}

func (o *ConnectionTwitter) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *ConnectionTwitter) GetStatus() ConnectionTwitterStatus {
	if o == nil {
		return ConnectionTwitterStatus("")
	}
	return o.Status
}

func (o *ConnectionTwitter) GetCreateDate() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreateDate
}

func (o *ConnectionTwitter) GetUpdateSchedule() *UpdateScheduleTypes {
	if o == nil {
		return nil
	}
	return o.UpdateSchedule
}

func (o *ConnectionTwitter) GetUpdateScheduleInterval() *UpdateScheduleModeInterval {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeInterval
	}
	return nil
}

func (o *ConnectionTwitter) GetUpdateScheduleHourly() *UpdateScheduleModeHourly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeHourly
	}
	return nil
}

func (o *ConnectionTwitter) GetUpdateScheduleDaily() *UpdateScheduleModeDaily {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeDaily
	}
	return nil
}

func (o *ConnectionTwitter) GetUpdateScheduleWeekly() *UpdateScheduleModeWeekly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeWeekly
	}
	return nil
}

func (o *ConnectionTwitter) GetUpdateScheduleMonthly() *UpdateScheduleModeMonthly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeMonthly
	}
	return nil
}

func (o *ConnectionTwitter) GetDefaultUpdateSchedule() []ConnectionTwitterDefaultUpdateSchedule {
	if o == nil {
		return []ConnectionTwitterDefaultUpdateSchedule{}
	}
	return o.DefaultUpdateSchedule
}

func (o *ConnectionTwitter) GetAppKey() string {
	if o == nil {
		return ""
	}
	return o.AppKey
}

func (o *ConnectionTwitter) GetTwitterUsernames() *string {
	if o == nil {
		return nil
	}
	return o.TwitterUsernames
}

type ConnectionTwitterInput struct {
	// The unique name of this connection.
	Name string                `json:"name"`
	Type ConnectionTwitterType `json:"type"`
	// The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information. When undefined, the pipeline will default to the schedule set on the source connection.
	UpdateSchedule *UpdateScheduleTypes `json:"updateSchedule,omitempty"`
	// This represents your Twitter developer app when making API requests. Generated under 'Consumer API keys'.
	AppKey string `json:"appKey"`
	// This authenticates your Twitter developer app when making API requests. Generated under 'Consumer API keys'.
	AppSecretKey string `json:"appSecretKey"`
	// This identifies your Twitter account when generating Ad reports. Generated under 'Access token & access token secret'.
	AccessToken string `json:"accessToken"`
	// This authenticates your Twitter account when generating Ad reports. Generated under 'Access token & access token secret'.
	AccessTokenSecret string `json:"accessTokenSecret"`
	// If you want to create pipelines from entities that uses Twitter API V2 endpoints you need to specify which Twitter accounts you want to retrieve data from. The usernames must be separated by comma and without the @
	TwitterUsernames *string `json:"twitterUsernames,omitempty"`
}

func (o *ConnectionTwitterInput) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ConnectionTwitterInput) GetType() ConnectionTwitterType {
	if o == nil {
		return ConnectionTwitterType("")
	}
	return o.Type
}

func (o *ConnectionTwitterInput) GetUpdateSchedule() *UpdateScheduleTypes {
	if o == nil {
		return nil
	}
	return o.UpdateSchedule
}

func (o *ConnectionTwitterInput) GetUpdateScheduleInterval() *UpdateScheduleModeInterval {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeInterval
	}
	return nil
}

func (o *ConnectionTwitterInput) GetUpdateScheduleHourly() *UpdateScheduleModeHourly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeHourly
	}
	return nil
}

func (o *ConnectionTwitterInput) GetUpdateScheduleDaily() *UpdateScheduleModeDaily {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeDaily
	}
	return nil
}

func (o *ConnectionTwitterInput) GetUpdateScheduleWeekly() *UpdateScheduleModeWeekly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeWeekly
	}
	return nil
}

func (o *ConnectionTwitterInput) GetUpdateScheduleMonthly() *UpdateScheduleModeMonthly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeMonthly
	}
	return nil
}

func (o *ConnectionTwitterInput) GetAppKey() string {
	if o == nil {
		return ""
	}
	return o.AppKey
}

func (o *ConnectionTwitterInput) GetAppSecretKey() string {
	if o == nil {
		return ""
	}
	return o.AppSecretKey
}

func (o *ConnectionTwitterInput) GetAccessToken() string {
	if o == nil {
		return ""
	}
	return o.AccessToken
}

func (o *ConnectionTwitterInput) GetAccessTokenSecret() string {
	if o == nil {
		return ""
	}
	return o.AccessTokenSecret
}

func (o *ConnectionTwitterInput) GetTwitterUsernames() *string {
	if o == nil {
		return nil
	}
	return o.TwitterUsernames
}
