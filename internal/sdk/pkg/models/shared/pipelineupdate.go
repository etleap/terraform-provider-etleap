// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/etleap/terraform-provider-etleap/internal/sdk/pkg/utils"
)

type RefreshScheduleModeMonthlyScheduleTypesPipelineUpdateMode string

const (
	RefreshScheduleModeMonthlyScheduleTypesPipelineUpdateModeMonthly RefreshScheduleModeMonthlyScheduleTypesPipelineUpdateMode = "MONTHLY"
)

func (e RefreshScheduleModeMonthlyScheduleTypesPipelineUpdateMode) ToPointer() *RefreshScheduleModeMonthlyScheduleTypesPipelineUpdateMode {
	return &e
}

func (e *RefreshScheduleModeMonthlyScheduleTypesPipelineUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MONTHLY":
		*e = RefreshScheduleModeMonthlyScheduleTypesPipelineUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeMonthlyScheduleTypesPipelineUpdateMode: %v", v)
	}
}

type RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode struct {
	Mode RefreshScheduleModeMonthlyScheduleTypesPipelineUpdateMode `json:"mode"`
	// Hour of day this schedule should trigger at (in UTC).
	HourOfDay int64 `json:"hourOfDay"`
	// Day of the month this schedule should trigger at (in UTC).
	DayOfMonth int64 `json:"dayOfMonth"`
}

func (o *RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode) GetMode() RefreshScheduleModeMonthlyScheduleTypesPipelineUpdateMode {
	if o == nil {
		return RefreshScheduleModeMonthlyScheduleTypesPipelineUpdateMode("")
	}
	return o.Mode
}

func (o *RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode) GetHourOfDay() int64 {
	if o == nil {
		return 0
	}
	return o.HourOfDay
}

func (o *RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode) GetDayOfMonth() int64 {
	if o == nil {
		return 0
	}
	return o.DayOfMonth
}

type RefreshScheduleModeWeeklyScheduleTypesPipelineUpdateMode string

const (
	RefreshScheduleModeWeeklyScheduleTypesPipelineUpdateModeWeekly RefreshScheduleModeWeeklyScheduleTypesPipelineUpdateMode = "WEEKLY"
)

func (e RefreshScheduleModeWeeklyScheduleTypesPipelineUpdateMode) ToPointer() *RefreshScheduleModeWeeklyScheduleTypesPipelineUpdateMode {
	return &e
}

func (e *RefreshScheduleModeWeeklyScheduleTypesPipelineUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "WEEKLY":
		*e = RefreshScheduleModeWeeklyScheduleTypesPipelineUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeWeeklyScheduleTypesPipelineUpdateMode: %v", v)
	}
}

type RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode struct {
	Mode RefreshScheduleModeWeeklyScheduleTypesPipelineUpdateMode `json:"mode"`
	// The day of the week this schedule should trigger at (in UTC).
	DayOfWeek int64 `json:"dayOfWeek"`
	// Hour of day this schedule should trigger at (in UTC).
	HourOfDay int64 `json:"hourOfDay"`
}

func (o *RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode) GetMode() RefreshScheduleModeWeeklyScheduleTypesPipelineUpdateMode {
	if o == nil {
		return RefreshScheduleModeWeeklyScheduleTypesPipelineUpdateMode("")
	}
	return o.Mode
}

func (o *RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode) GetDayOfWeek() int64 {
	if o == nil {
		return 0
	}
	return o.DayOfWeek
}

func (o *RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode) GetHourOfDay() int64 {
	if o == nil {
		return 0
	}
	return o.HourOfDay
}

type RefreshScheduleModeDailyScheduleTypesPipelineUpdateMode string

const (
	RefreshScheduleModeDailyScheduleTypesPipelineUpdateModeDaily RefreshScheduleModeDailyScheduleTypesPipelineUpdateMode = "DAILY"
)

func (e RefreshScheduleModeDailyScheduleTypesPipelineUpdateMode) ToPointer() *RefreshScheduleModeDailyScheduleTypesPipelineUpdateMode {
	return &e
}

func (e *RefreshScheduleModeDailyScheduleTypesPipelineUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DAILY":
		*e = RefreshScheduleModeDailyScheduleTypesPipelineUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeDailyScheduleTypesPipelineUpdateMode: %v", v)
	}
}

type RefreshScheduleModeDailyScheduleTypesDailyScheduleMode struct {
	Mode RefreshScheduleModeDailyScheduleTypesPipelineUpdateMode `json:"mode"`
	// Hour of day this schedule should trigger at (in UTC).
	HourOfDay int64 `json:"hourOfDay"`
}

func (o *RefreshScheduleModeDailyScheduleTypesDailyScheduleMode) GetMode() RefreshScheduleModeDailyScheduleTypesPipelineUpdateMode {
	if o == nil {
		return RefreshScheduleModeDailyScheduleTypesPipelineUpdateMode("")
	}
	return o.Mode
}

func (o *RefreshScheduleModeDailyScheduleTypesDailyScheduleMode) GetHourOfDay() int64 {
	if o == nil {
		return 0
	}
	return o.HourOfDay
}

type RefreshScheduleModeHourlyScheduleTypesPipelineUpdateMode string

const (
	RefreshScheduleModeHourlyScheduleTypesPipelineUpdateModeHourly RefreshScheduleModeHourlyScheduleTypesPipelineUpdateMode = "HOURLY"
)

func (e RefreshScheduleModeHourlyScheduleTypesPipelineUpdateMode) ToPointer() *RefreshScheduleModeHourlyScheduleTypesPipelineUpdateMode {
	return &e
}

func (e *RefreshScheduleModeHourlyScheduleTypesPipelineUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HOURLY":
		*e = RefreshScheduleModeHourlyScheduleTypesPipelineUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeHourlyScheduleTypesPipelineUpdateMode: %v", v)
	}
}

type RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode struct {
	Mode RefreshScheduleModeHourlyScheduleTypesPipelineUpdateMode `json:"mode"`
}

func (o *RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode) GetMode() RefreshScheduleModeHourlyScheduleTypesPipelineUpdateMode {
	if o == nil {
		return RefreshScheduleModeHourlyScheduleTypesPipelineUpdateMode("")
	}
	return o.Mode
}

type RefreshScheduleModeNeverScheduleTypesPipelineUpdateMode string

const (
	RefreshScheduleModeNeverScheduleTypesPipelineUpdateModeNever RefreshScheduleModeNeverScheduleTypesPipelineUpdateMode = "NEVER"
)

func (e RefreshScheduleModeNeverScheduleTypesPipelineUpdateMode) ToPointer() *RefreshScheduleModeNeverScheduleTypesPipelineUpdateMode {
	return &e
}

func (e *RefreshScheduleModeNeverScheduleTypesPipelineUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NEVER":
		*e = RefreshScheduleModeNeverScheduleTypesPipelineUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RefreshScheduleModeNeverScheduleTypesPipelineUpdateMode: %v", v)
	}
}

type RefreshScheduleModeNeverScheduleTypesNeverScheduleMode struct {
	Mode RefreshScheduleModeNeverScheduleTypesPipelineUpdateMode `json:"mode"`
}

func (o *RefreshScheduleModeNeverScheduleTypesNeverScheduleMode) GetMode() RefreshScheduleModeNeverScheduleTypesPipelineUpdateMode {
	if o == nil {
		return RefreshScheduleModeNeverScheduleTypesPipelineUpdateMode("")
	}
	return o.Mode
}

type PipelineUpdateScheduleTypesType string

const (
	PipelineUpdateScheduleTypesTypeMonthly PipelineUpdateScheduleTypesType = "MONTHLY"
	PipelineUpdateScheduleTypesTypeHourly  PipelineUpdateScheduleTypesType = "HOURLY"
	PipelineUpdateScheduleTypesTypeNever   PipelineUpdateScheduleTypesType = "NEVER"
	PipelineUpdateScheduleTypesTypeDaily   PipelineUpdateScheduleTypesType = "DAILY"
	PipelineUpdateScheduleTypesTypeWeekly  PipelineUpdateScheduleTypesType = "WEEKLY"
)

// PipelineUpdateScheduleTypes - A pipeline refresh processes all data in your source from the beginning to re-establish consistency with your destination. The pipeline refresh schedule defines when Etleap should automatically refresh the pipeline. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.
//
// Setting this to `null` is equivalent to setting the Refresh Schedule to `NEVER`.
type PipelineUpdateScheduleTypes struct {
	RefreshScheduleModeNeverScheduleTypesNeverScheduleMode     *RefreshScheduleModeNeverScheduleTypesNeverScheduleMode
	RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode   *RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode
	RefreshScheduleModeDailyScheduleTypesDailyScheduleMode     *RefreshScheduleModeDailyScheduleTypesDailyScheduleMode
	RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode   *RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode
	RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode *RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode

	Type PipelineUpdateScheduleTypesType
}

func CreatePipelineUpdateScheduleTypesMonthly(monthly RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode) PipelineUpdateScheduleTypes {
	typ := PipelineUpdateScheduleTypesTypeMonthly

	typStr := RefreshScheduleModeMonthlyScheduleTypesPipelineUpdateMode(typ)
	monthly.Mode = typStr

	return PipelineUpdateScheduleTypes{
		RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode: &monthly,
		Type: typ,
	}
}

func CreatePipelineUpdateScheduleTypesHourly(hourly RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode) PipelineUpdateScheduleTypes {
	typ := PipelineUpdateScheduleTypesTypeHourly

	typStr := RefreshScheduleModeHourlyScheduleTypesPipelineUpdateMode(typ)
	hourly.Mode = typStr

	return PipelineUpdateScheduleTypes{
		RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode: &hourly,
		Type: typ,
	}
}

func CreatePipelineUpdateScheduleTypesNever(never RefreshScheduleModeNeverScheduleTypesNeverScheduleMode) PipelineUpdateScheduleTypes {
	typ := PipelineUpdateScheduleTypesTypeNever

	typStr := RefreshScheduleModeNeverScheduleTypesPipelineUpdateMode(typ)
	never.Mode = typStr

	return PipelineUpdateScheduleTypes{
		RefreshScheduleModeNeverScheduleTypesNeverScheduleMode: &never,
		Type: typ,
	}
}

func CreatePipelineUpdateScheduleTypesDaily(daily RefreshScheduleModeDailyScheduleTypesDailyScheduleMode) PipelineUpdateScheduleTypes {
	typ := PipelineUpdateScheduleTypesTypeDaily

	typStr := RefreshScheduleModeDailyScheduleTypesPipelineUpdateMode(typ)
	daily.Mode = typStr

	return PipelineUpdateScheduleTypes{
		RefreshScheduleModeDailyScheduleTypesDailyScheduleMode: &daily,
		Type: typ,
	}
}

func CreatePipelineUpdateScheduleTypesWeekly(weekly RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode) PipelineUpdateScheduleTypes {
	typ := PipelineUpdateScheduleTypesTypeWeekly

	typStr := RefreshScheduleModeWeeklyScheduleTypesPipelineUpdateMode(typ)
	weekly.Mode = typStr

	return PipelineUpdateScheduleTypes{
		RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode: &weekly,
		Type: typ,
	}
}

func (u *PipelineUpdateScheduleTypes) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Mode string
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Mode {
	case "MONTHLY":
		refreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode := new(RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode)
		if err := utils.UnmarshalJSON(data, &refreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode = refreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode
		u.Type = PipelineUpdateScheduleTypesTypeMonthly
		return nil
	case "HOURLY":
		refreshScheduleModeHourlyScheduleTypesHourlyScheduleMode := new(RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode)
		if err := utils.UnmarshalJSON(data, &refreshScheduleModeHourlyScheduleTypesHourlyScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode = refreshScheduleModeHourlyScheduleTypesHourlyScheduleMode
		u.Type = PipelineUpdateScheduleTypesTypeHourly
		return nil
	case "NEVER":
		refreshScheduleModeNeverScheduleTypesNeverScheduleMode := new(RefreshScheduleModeNeverScheduleTypesNeverScheduleMode)
		if err := utils.UnmarshalJSON(data, &refreshScheduleModeNeverScheduleTypesNeverScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.RefreshScheduleModeNeverScheduleTypesNeverScheduleMode = refreshScheduleModeNeverScheduleTypesNeverScheduleMode
		u.Type = PipelineUpdateScheduleTypesTypeNever
		return nil
	case "DAILY":
		refreshScheduleModeDailyScheduleTypesDailyScheduleMode := new(RefreshScheduleModeDailyScheduleTypesDailyScheduleMode)
		if err := utils.UnmarshalJSON(data, &refreshScheduleModeDailyScheduleTypesDailyScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.RefreshScheduleModeDailyScheduleTypesDailyScheduleMode = refreshScheduleModeDailyScheduleTypesDailyScheduleMode
		u.Type = PipelineUpdateScheduleTypesTypeDaily
		return nil
	case "WEEKLY":
		refreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode := new(RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode)
		if err := utils.UnmarshalJSON(data, &refreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode = refreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode
		u.Type = PipelineUpdateScheduleTypesTypeWeekly
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u PipelineUpdateScheduleTypes) MarshalJSON() ([]byte, error) {
	if u.RefreshScheduleModeNeverScheduleTypesNeverScheduleMode != nil {
		return utils.MarshalJSON(u.RefreshScheduleModeNeverScheduleTypesNeverScheduleMode, "", true)
	}

	if u.RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode != nil {
		return utils.MarshalJSON(u.RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode, "", true)
	}

	if u.RefreshScheduleModeDailyScheduleTypesDailyScheduleMode != nil {
		return utils.MarshalJSON(u.RefreshScheduleModeDailyScheduleTypesDailyScheduleMode, "", true)
	}

	if u.RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode != nil {
		return utils.MarshalJSON(u.RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode, "", true)
	}

	if u.RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode != nil {
		return utils.MarshalJSON(u.RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// PipelineUpdateAction - Whether Etleap should STOP the pipeline or NOTIFY once the `threshold` is reached.
type PipelineUpdateAction string

const (
	PipelineUpdateActionStop   PipelineUpdateAction = "STOP"
	PipelineUpdateActionNotify PipelineUpdateAction = "NOTIFY"
)

func (e PipelineUpdateAction) ToPointer() *PipelineUpdateAction {
	return &e
}

func (e *PipelineUpdateAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STOP":
		fallthrough
	case "NOTIFY":
		*e = PipelineUpdateAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PipelineUpdateAction: %v", v)
	}
}

type PipelineUpdateParsingErrorSettings struct {
	// The parsing error threshold, in percentage points, for the `action` to be triggered.
	Threshold float64 `json:"threshold"`
	// Whether Etleap should STOP the pipeline or NOTIFY once the `threshold` is reached.
	Action PipelineUpdateAction `json:"action"`
}

func (o *PipelineUpdateParsingErrorSettings) GetThreshold() float64 {
	if o == nil {
		return 0.0
	}
	return o.Threshold
}

func (o *PipelineUpdateParsingErrorSettings) GetAction() PipelineUpdateAction {
	if o == nil {
		return PipelineUpdateAction("")
	}
	return o.Action
}

type UpdateScheduleModeMonthlyUpdateScheduleTypesMode string

const (
	UpdateScheduleModeMonthlyUpdateScheduleTypesModeMonthly UpdateScheduleModeMonthlyUpdateScheduleTypesMode = "MONTHLY"
)

func (e UpdateScheduleModeMonthlyUpdateScheduleTypesMode) ToPointer() *UpdateScheduleModeMonthlyUpdateScheduleTypesMode {
	return &e
}

func (e *UpdateScheduleModeMonthlyUpdateScheduleTypesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MONTHLY":
		*e = UpdateScheduleModeMonthlyUpdateScheduleTypesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateScheduleModeMonthlyUpdateScheduleTypesMode: %v", v)
	}
}

// MonthlyUpdateScheduleMode - The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.
type MonthlyUpdateScheduleMode struct {
	Mode UpdateScheduleModeMonthlyUpdateScheduleTypesMode `json:"mode"`
	// Hour of day the  pipeline update should be started at (in UTC).
	HourOfDay  int64 `json:"hourOfDay"`
	DayOfMonth int64 `json:"dayOfMonth"`
}

func (o *MonthlyUpdateScheduleMode) GetMode() UpdateScheduleModeMonthlyUpdateScheduleTypesMode {
	if o == nil {
		return UpdateScheduleModeMonthlyUpdateScheduleTypesMode("")
	}
	return o.Mode
}

func (o *MonthlyUpdateScheduleMode) GetHourOfDay() int64 {
	if o == nil {
		return 0
	}
	return o.HourOfDay
}

func (o *MonthlyUpdateScheduleMode) GetDayOfMonth() int64 {
	if o == nil {
		return 0
	}
	return o.DayOfMonth
}

type UpdateScheduleModeWeeklyUpdateScheduleTypesMode string

const (
	UpdateScheduleModeWeeklyUpdateScheduleTypesModeWeekly UpdateScheduleModeWeeklyUpdateScheduleTypesMode = "WEEKLY"
)

func (e UpdateScheduleModeWeeklyUpdateScheduleTypesMode) ToPointer() *UpdateScheduleModeWeeklyUpdateScheduleTypesMode {
	return &e
}

func (e *UpdateScheduleModeWeeklyUpdateScheduleTypesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "WEEKLY":
		*e = UpdateScheduleModeWeeklyUpdateScheduleTypesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateScheduleModeWeeklyUpdateScheduleTypesMode: %v", v)
	}
}

// WeeklyUpdateScheduleMode - The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.
type WeeklyUpdateScheduleMode struct {
	Mode      UpdateScheduleModeWeeklyUpdateScheduleTypesMode `json:"mode"`
	DayOfWeek int64                                           `json:"dayOfWeek"`
	// Hour of day the  pipeline update should be started at (in UTC).
	HourOfDay int64 `json:"hourOfDay"`
}

func (o *WeeklyUpdateScheduleMode) GetMode() UpdateScheduleModeWeeklyUpdateScheduleTypesMode {
	if o == nil {
		return UpdateScheduleModeWeeklyUpdateScheduleTypesMode("")
	}
	return o.Mode
}

func (o *WeeklyUpdateScheduleMode) GetDayOfWeek() int64 {
	if o == nil {
		return 0
	}
	return o.DayOfWeek
}

func (o *WeeklyUpdateScheduleMode) GetHourOfDay() int64 {
	if o == nil {
		return 0
	}
	return o.HourOfDay
}

type UpdateScheduleModeDailyUpdateScheduleTypesMode string

const (
	UpdateScheduleModeDailyUpdateScheduleTypesModeDaily UpdateScheduleModeDailyUpdateScheduleTypesMode = "DAILY"
)

func (e UpdateScheduleModeDailyUpdateScheduleTypesMode) ToPointer() *UpdateScheduleModeDailyUpdateScheduleTypesMode {
	return &e
}

func (e *UpdateScheduleModeDailyUpdateScheduleTypesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DAILY":
		*e = UpdateScheduleModeDailyUpdateScheduleTypesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateScheduleModeDailyUpdateScheduleTypesMode: %v", v)
	}
}

// DailyUpdateScheduleMode - The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.
type DailyUpdateScheduleMode struct {
	Mode UpdateScheduleModeDailyUpdateScheduleTypesMode `json:"mode"`
	// Hour of day the  pipeline update should be started at (in UTC).
	HourOfDay int64 `json:"hourOfDay"`
}

func (o *DailyUpdateScheduleMode) GetMode() UpdateScheduleModeDailyUpdateScheduleTypesMode {
	if o == nil {
		return UpdateScheduleModeDailyUpdateScheduleTypesMode("")
	}
	return o.Mode
}

func (o *DailyUpdateScheduleMode) GetHourOfDay() int64 {
	if o == nil {
		return 0
	}
	return o.HourOfDay
}

type UpdateScheduleModeHourlyUpdateScheduleTypesMode string

const (
	UpdateScheduleModeHourlyUpdateScheduleTypesModeHourly UpdateScheduleModeHourlyUpdateScheduleTypesMode = "HOURLY"
)

func (e UpdateScheduleModeHourlyUpdateScheduleTypesMode) ToPointer() *UpdateScheduleModeHourlyUpdateScheduleTypesMode {
	return &e
}

func (e *UpdateScheduleModeHourlyUpdateScheduleTypesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HOURLY":
		*e = UpdateScheduleModeHourlyUpdateScheduleTypesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateScheduleModeHourlyUpdateScheduleTypesMode: %v", v)
	}
}

// HourlyUpdateScheduleMode - The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.
type HourlyUpdateScheduleMode struct {
	Mode UpdateScheduleModeHourlyUpdateScheduleTypesMode `json:"mode"`
}

func (o *HourlyUpdateScheduleMode) GetMode() UpdateScheduleModeHourlyUpdateScheduleTypesMode {
	if o == nil {
		return UpdateScheduleModeHourlyUpdateScheduleTypesMode("")
	}
	return o.Mode
}

type UpdateScheduleTypesMode string

const (
	UpdateScheduleTypesModeInterval UpdateScheduleTypesMode = "INTERVAL"
)

func (e UpdateScheduleTypesMode) ToPointer() *UpdateScheduleTypesMode {
	return &e
}

func (e *UpdateScheduleTypesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INTERVAL":
		*e = UpdateScheduleTypesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateScheduleTypesMode: %v", v)
	}
}

// IntervalUpdateScheduleMode - The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.
type IntervalUpdateScheduleMode struct {
	Mode UpdateScheduleTypesMode `json:"mode"`
	// Time to wait before new data is pulled (in minutes).
	IntervalMinutes int64 `json:"intervalMinutes"`
}

func (o *IntervalUpdateScheduleMode) GetMode() UpdateScheduleTypesMode {
	if o == nil {
		return UpdateScheduleTypesMode("")
	}
	return o.Mode
}

func (o *IntervalUpdateScheduleMode) GetIntervalMinutes() int64 {
	if o == nil {
		return 0
	}
	return o.IntervalMinutes
}

type PipelineUpdateUpdateScheduleTypesType string

const (
	PipelineUpdateUpdateScheduleTypesTypeMonthly  PipelineUpdateUpdateScheduleTypesType = "MONTHLY"
	PipelineUpdateUpdateScheduleTypesTypeHourly   PipelineUpdateUpdateScheduleTypesType = "HOURLY"
	PipelineUpdateUpdateScheduleTypesTypeInterval PipelineUpdateUpdateScheduleTypesType = "INTERVAL"
	PipelineUpdateUpdateScheduleTypesTypeDaily    PipelineUpdateUpdateScheduleTypesType = "DAILY"
	PipelineUpdateUpdateScheduleTypesTypeWeekly   PipelineUpdateUpdateScheduleTypesType = "WEEKLY"
)

// PipelineUpdateUpdateScheduleTypes - Setting the `updateSchedule` to `null` will remove the Pipeline Update Schedule and revert to using the Connection Update Schedule.
type PipelineUpdateUpdateScheduleTypes struct {
	IntervalUpdateScheduleMode *IntervalUpdateScheduleMode
	HourlyUpdateScheduleMode   *HourlyUpdateScheduleMode
	DailyUpdateScheduleMode    *DailyUpdateScheduleMode
	WeeklyUpdateScheduleMode   *WeeklyUpdateScheduleMode
	MonthlyUpdateScheduleMode  *MonthlyUpdateScheduleMode

	Type PipelineUpdateUpdateScheduleTypesType
}

func CreatePipelineUpdateUpdateScheduleTypesMonthly(monthly MonthlyUpdateScheduleMode) PipelineUpdateUpdateScheduleTypes {
	typ := PipelineUpdateUpdateScheduleTypesTypeMonthly

	typStr := UpdateScheduleModeMonthlyUpdateScheduleTypesMode(typ)
	monthly.Mode = typStr

	return PipelineUpdateUpdateScheduleTypes{
		MonthlyUpdateScheduleMode: &monthly,
		Type:                      typ,
	}
}

func CreatePipelineUpdateUpdateScheduleTypesHourly(hourly HourlyUpdateScheduleMode) PipelineUpdateUpdateScheduleTypes {
	typ := PipelineUpdateUpdateScheduleTypesTypeHourly

	typStr := UpdateScheduleModeHourlyUpdateScheduleTypesMode(typ)
	hourly.Mode = typStr

	return PipelineUpdateUpdateScheduleTypes{
		HourlyUpdateScheduleMode: &hourly,
		Type:                     typ,
	}
}

func CreatePipelineUpdateUpdateScheduleTypesInterval(interval IntervalUpdateScheduleMode) PipelineUpdateUpdateScheduleTypes {
	typ := PipelineUpdateUpdateScheduleTypesTypeInterval

	typStr := UpdateScheduleTypesMode(typ)
	interval.Mode = typStr

	return PipelineUpdateUpdateScheduleTypes{
		IntervalUpdateScheduleMode: &interval,
		Type:                       typ,
	}
}

func CreatePipelineUpdateUpdateScheduleTypesDaily(daily DailyUpdateScheduleMode) PipelineUpdateUpdateScheduleTypes {
	typ := PipelineUpdateUpdateScheduleTypesTypeDaily

	typStr := UpdateScheduleModeDailyUpdateScheduleTypesMode(typ)
	daily.Mode = typStr

	return PipelineUpdateUpdateScheduleTypes{
		DailyUpdateScheduleMode: &daily,
		Type:                    typ,
	}
}

func CreatePipelineUpdateUpdateScheduleTypesWeekly(weekly WeeklyUpdateScheduleMode) PipelineUpdateUpdateScheduleTypes {
	typ := PipelineUpdateUpdateScheduleTypesTypeWeekly

	typStr := UpdateScheduleModeWeeklyUpdateScheduleTypesMode(typ)
	weekly.Mode = typStr

	return PipelineUpdateUpdateScheduleTypes{
		WeeklyUpdateScheduleMode: &weekly,
		Type:                     typ,
	}
}

func (u *PipelineUpdateUpdateScheduleTypes) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Mode string
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Mode {
	case "MONTHLY":
		monthlyUpdateScheduleMode := new(MonthlyUpdateScheduleMode)
		if err := utils.UnmarshalJSON(data, &monthlyUpdateScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.MonthlyUpdateScheduleMode = monthlyUpdateScheduleMode
		u.Type = PipelineUpdateUpdateScheduleTypesTypeMonthly
		return nil
	case "HOURLY":
		hourlyUpdateScheduleMode := new(HourlyUpdateScheduleMode)
		if err := utils.UnmarshalJSON(data, &hourlyUpdateScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.HourlyUpdateScheduleMode = hourlyUpdateScheduleMode
		u.Type = PipelineUpdateUpdateScheduleTypesTypeHourly
		return nil
	case "INTERVAL":
		intervalUpdateScheduleMode := new(IntervalUpdateScheduleMode)
		if err := utils.UnmarshalJSON(data, &intervalUpdateScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.IntervalUpdateScheduleMode = intervalUpdateScheduleMode
		u.Type = PipelineUpdateUpdateScheduleTypesTypeInterval
		return nil
	case "DAILY":
		dailyUpdateScheduleMode := new(DailyUpdateScheduleMode)
		if err := utils.UnmarshalJSON(data, &dailyUpdateScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.DailyUpdateScheduleMode = dailyUpdateScheduleMode
		u.Type = PipelineUpdateUpdateScheduleTypesTypeDaily
		return nil
	case "WEEKLY":
		weeklyUpdateScheduleMode := new(WeeklyUpdateScheduleMode)
		if err := utils.UnmarshalJSON(data, &weeklyUpdateScheduleMode, "", true, true); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.WeeklyUpdateScheduleMode = weeklyUpdateScheduleMode
		u.Type = PipelineUpdateUpdateScheduleTypesTypeWeekly
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u PipelineUpdateUpdateScheduleTypes) MarshalJSON() ([]byte, error) {
	if u.IntervalUpdateScheduleMode != nil {
		return utils.MarshalJSON(u.IntervalUpdateScheduleMode, "", true)
	}

	if u.HourlyUpdateScheduleMode != nil {
		return utils.MarshalJSON(u.HourlyUpdateScheduleMode, "", true)
	}

	if u.DailyUpdateScheduleMode != nil {
		return utils.MarshalJSON(u.DailyUpdateScheduleMode, "", true)
	}

	if u.WeeklyUpdateScheduleMode != nil {
		return utils.MarshalJSON(u.WeeklyUpdateScheduleMode, "", true)
	}

	if u.MonthlyUpdateScheduleMode != nil {
		return utils.MarshalJSON(u.MonthlyUpdateScheduleMode, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type PipelineUpdate struct {
	Name              *string             `json:"name,omitempty"`
	DestinationUpdate []DestinationUpdate `json:"destination,omitempty"`
	// A list of users' email to share the pipeline with.
	//
	// A pipeline cannot be unshared; therefore future calls can only add to this list.
	//
	// Deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
	Shares []string           `json:"shares,omitempty"`
	Paused *bool              `json:"paused,omitempty"`
	Source *SourceTypesUpdate `json:"source,omitempty"`
	// A pipeline refresh processes all data in your source from the beginning to re-establish consistency with your destination. The pipeline refresh schedule defines when Etleap should automatically refresh the pipeline. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.
	//
	// Setting this to `null` is equivalent to setting the Refresh Schedule to `NEVER`.
	RefreshSchedule      *PipelineUpdateScheduleTypes        `json:"refreshSchedule,omitempty"`
	ParsingErrorSettings *PipelineUpdateParsingErrorSettings `json:"parsingErrorSettings,omitempty"`
	// Setting the `updateSchedule` to `null` will remove the Pipeline Update Schedule and revert to using the Connection Update Schedule.
	UpdateSchedule *PipelineUpdateUpdateScheduleTypes `json:"updateSchedule,omitempty"`
}

func (o *PipelineUpdate) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *PipelineUpdate) GetDestinationUpdate() []DestinationUpdate {
	if o == nil {
		return nil
	}
	return o.DestinationUpdate
}

func (o *PipelineUpdate) GetShares() []string {
	if o == nil {
		return nil
	}
	return o.Shares
}

func (o *PipelineUpdate) GetPaused() *bool {
	if o == nil {
		return nil
	}
	return o.Paused
}

func (o *PipelineUpdate) GetSource() *SourceTypesUpdate {
	if o == nil {
		return nil
	}
	return o.Source
}

func (o *PipelineUpdate) GetSourceGoogleCloudStorage() *SourceGoogleCloudStorageUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceGoogleCloudStorageUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceJiraCloud() *SourceJiraCloudUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceJiraCloudUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceErpx() *SourceErpxUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceErpxUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceRaveMedidata() *SourceRaveMedidataUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceRaveMedidataUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceDeltaLake() *SourceDeltaLakeUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceDeltaLakeUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceDb2() *SourceDb2Update {
	if v := o.GetSource(); v != nil {
		return v.SourceDb2Update
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSnowflake() *SourceSnowflakeUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSnowflakeUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceTikTokAds() *SourceTikTokAdsUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceTikTokAdsUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceOutlook() *SourceOutlookUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceOutlookUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSnowflakeSharded() *SourceSnowflakeShardedUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSnowflakeShardedUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceFreshchat() *SourceFreshchatUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceFreshchatUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceVeeva() *SourceVeevaUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceVeevaUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceWorkdayReport() *SourceWorkdayReportUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceWorkdayReportUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceS3Input() *SourceS3InputUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceS3InputUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceOutreach() *SourceOutreachUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceOutreachUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceRecurly() *SourceRecurlyUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceRecurlyUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceGoogleAds() *SourceGoogleAdsUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceGoogleAdsUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceQuoraAds() *SourceQuoraAdsUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceQuoraAdsUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceElluminate() *SourceElluminateUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceElluminateUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceStreaming() *SourceStreamingUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceStreamingUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceDb2Sharded() *SourceDb2ShardedUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceDb2ShardedUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceLdap() *SourceLdapUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceLdapUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceMysqlSharded() *SourceMysqlShardedUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceMysqlShardedUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceImpactRadius() *SourceImpactRadiusUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceImpactRadiusUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceJira() *SourceJiraUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceJiraUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceVerizonMediaDsp() *SourceVerizonMediaDspUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceVerizonMediaDspUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceTwitterAds() *SourceTwitterUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceTwitterUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceIntercom() *SourceIntercomUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceIntercomUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceCoupa() *SourceCoupaUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceCoupaUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceTwilio() *SourceTwilioUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceTwilioUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceBingAds() *SourceBingAdsUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceBingAdsUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSalesforce() *SourceSalesforceUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSalesforceUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSapHana() *SourceSapHanaUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSapHanaUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceCriteo() *SourceCriteoUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceCriteoUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceFtp() *SourceFtpUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceFtpUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSquare() *SourceSquareUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSquareUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceEgnyte() *SourceEgnyteUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceEgnyteUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceUserDefinedAPI() *SourceUserDefinedAPIUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceUserDefinedAPIUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSapConcur() *SourceSapConcurUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSapConcurUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceUservoice() *SourceUserVoiceUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceUserVoiceUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceNetsuite() *SourceNetsuiteUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceNetsuiteUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceTheTradeDesk() *SourceTheTradeDeskUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceTheTradeDeskUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceMongodb() *SourceMongodbUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceMongodbUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceJiraAlign() *SourceJiraAlignUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceJiraAlignUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceGong() *SourceGongUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceGongUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourcePinterestAds() *SourcePinterestAdsUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourcePinterestAdsUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceShopify() *SourceShopifyUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceShopifyUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceNetsuiteV2() *SourceNetsuiteV2Update {
	if v := o.GetSource(); v != nil {
		return v.SourceNetsuiteV2Update
	}
	return nil
}

func (o *PipelineUpdate) GetSourceBraintree() *SourceBraintreeUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceBraintreeUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSQLServer() *SourceSQLServerUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSQLServerUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSalesforceMarketingCloud() *SourceSalesforceMarketingCloudUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSalesforceMarketingCloudUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSftp() *SourceSftpUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSftpUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceS3Legacy() *SourceS3LegacyUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceS3LegacyUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceBlackline() *SourceBlacklineUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceBlacklineUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceRedshift() *SourceRedshiftUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceRedshiftUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceStripe() *SourceStripeUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceStripeUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceFifteenFive() *SourceFifteenFiveUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceFifteenFiveUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSQLServerSharded() *SourceSQLServerShardedUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSQLServerShardedUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceKustomer() *SourceKustomerUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceKustomerUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceKafka() *SourceKafkaUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceKafkaUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceZoomPhone() *SourceZoomPhoneUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceZoomPhoneUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceFacebookAds() *SourceFacebookAdsUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceFacebookAdsUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceLinkedInAds() *SourceLinkedInAdsUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceLinkedInAdsUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceMysql() *SourceMysqlUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceMysqlUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceFreshworks() *SourceFreshworksUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceFreshworksUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceWorkfront() *SourceWorkfrontUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceWorkfrontUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceHubspot() *SourceHubspotUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceHubspotUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceMarketo() *SourceMarketoUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceMarketoUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSumtotal() *SourceSumTotalUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSumTotalUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSapHanaSharded() *SourceSapHanaShardedUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSapHanaShardedUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceGoogleAnalyticsGa4() *SourceGoogleAnalyticsGa4Update {
	if v := o.GetSource(); v != nil {
		return v.SourceGoogleAnalyticsGa4Update
	}
	return nil
}

func (o *PipelineUpdate) GetSourceGoogleSheets() *SourceGoogleSheetsUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceGoogleSheetsUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceBigquery() *SourceBigQueryUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceBigQueryUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceConfluentCloud() *SourceConfluentCloudUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceConfluentCloudUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceEloqua() *SourceEloquaUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceEloquaUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceLdapVirtualListView() *SourceLdapVirtualListViewUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceLdapVirtualListViewUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourcePostgresSharded() *SourcePostgresShardedUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourcePostgresShardedUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceMicrosoftEntraID() *SourceMicrosoftEntraIDUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceMicrosoftEntraIDUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSkyward() *SourceSkywardUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSkywardUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceServiceNow() *SourceServiceNowUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceServiceNowUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceActiveCampaign() *SourceActiveCampaignUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceActiveCampaignUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceMixpanel() *SourceMixpanelUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceMixpanelUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourcePostgres() *SourcePostgresUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourcePostgresUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceOracleSharded() *SourceOracleShardedUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceOracleShardedUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceElasticsearch() *SourceElasticSearchUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceElasticSearchUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceZendesk() *SourceZendeskUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceZendeskUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceRedshiftSharded() *SourceRedshiftShardedUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceRedshiftShardedUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceZuora() *SourceZuoraUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceZuoraUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceFreshsales() *SourceFreshsalesUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceFreshsalesUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceOracle() *SourceOracleUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceOracleUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSeismic() *SourceSeismicUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSeismicUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetSourceSnapchatAds() *SourceSnapchatAdsUpdate {
	if v := o.GetSource(); v != nil {
		return v.SourceSnapchatAdsUpdate
	}
	return nil
}

func (o *PipelineUpdate) GetRefreshSchedule() *PipelineUpdateScheduleTypes {
	if o == nil {
		return nil
	}
	return o.RefreshSchedule
}

func (o *PipelineUpdate) GetRefreshScheduleMonthly() *RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode {
	if v := o.GetRefreshSchedule(); v != nil {
		return v.RefreshScheduleModeMonthlyScheduleTypesMonthlyScheduleMode
	}
	return nil
}

func (o *PipelineUpdate) GetRefreshScheduleHourly() *RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode {
	if v := o.GetRefreshSchedule(); v != nil {
		return v.RefreshScheduleModeHourlyScheduleTypesHourlyScheduleMode
	}
	return nil
}

func (o *PipelineUpdate) GetRefreshScheduleNever() *RefreshScheduleModeNeverScheduleTypesNeverScheduleMode {
	if v := o.GetRefreshSchedule(); v != nil {
		return v.RefreshScheduleModeNeverScheduleTypesNeverScheduleMode
	}
	return nil
}

func (o *PipelineUpdate) GetRefreshScheduleDaily() *RefreshScheduleModeDailyScheduleTypesDailyScheduleMode {
	if v := o.GetRefreshSchedule(); v != nil {
		return v.RefreshScheduleModeDailyScheduleTypesDailyScheduleMode
	}
	return nil
}

func (o *PipelineUpdate) GetRefreshScheduleWeekly() *RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode {
	if v := o.GetRefreshSchedule(); v != nil {
		return v.RefreshScheduleModeWeeklyScheduleTypesWeeklyScheduleMode
	}
	return nil
}

func (o *PipelineUpdate) GetParsingErrorSettings() *PipelineUpdateParsingErrorSettings {
	if o == nil {
		return nil
	}
	return o.ParsingErrorSettings
}

func (o *PipelineUpdate) GetUpdateSchedule() *PipelineUpdateUpdateScheduleTypes {
	if o == nil {
		return nil
	}
	return o.UpdateSchedule
}

func (o *PipelineUpdate) GetUpdateScheduleMonthly() *MonthlyUpdateScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.MonthlyUpdateScheduleMode
	}
	return nil
}

func (o *PipelineUpdate) GetUpdateScheduleHourly() *HourlyUpdateScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.HourlyUpdateScheduleMode
	}
	return nil
}

func (o *PipelineUpdate) GetUpdateScheduleInterval() *IntervalUpdateScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.IntervalUpdateScheduleMode
	}
	return nil
}

func (o *PipelineUpdate) GetUpdateScheduleDaily() *DailyUpdateScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.DailyUpdateScheduleMode
	}
	return nil
}

func (o *PipelineUpdate) GetUpdateScheduleWeekly() *WeeklyUpdateScheduleMode {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.WeeklyUpdateScheduleMode
	}
	return nil
}
