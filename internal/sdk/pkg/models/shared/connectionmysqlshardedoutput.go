// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/etleap/terraform-provider-etleap/internal/sdk/pkg/utils"
	"time"
)

// ConnectionMysqlShardedStatus - The current status of the connection.
type ConnectionMysqlShardedStatus string

const (
	ConnectionMysqlShardedStatusUnknown     ConnectionMysqlShardedStatus = "UNKNOWN"
	ConnectionMysqlShardedStatusUp          ConnectionMysqlShardedStatus = "UP"
	ConnectionMysqlShardedStatusDown        ConnectionMysqlShardedStatus = "DOWN"
	ConnectionMysqlShardedStatusResize      ConnectionMysqlShardedStatus = "RESIZE"
	ConnectionMysqlShardedStatusMaintenance ConnectionMysqlShardedStatus = "MAINTENANCE"
	ConnectionMysqlShardedStatusQuota       ConnectionMysqlShardedStatus = "QUOTA"
	ConnectionMysqlShardedStatusCreating    ConnectionMysqlShardedStatus = "CREATING"
)

func (e ConnectionMysqlShardedStatus) ToPointer() *ConnectionMysqlShardedStatus {
	return &e
}

func (e *ConnectionMysqlShardedStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNKNOWN":
		fallthrough
	case "UP":
		fallthrough
	case "DOWN":
		fallthrough
	case "RESIZE":
		fallthrough
	case "MAINTENANCE":
		fallthrough
	case "QUOTA":
		fallthrough
	case "CREATING":
		*e = ConnectionMysqlShardedStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConnectionMysqlShardedStatus: %v", v)
	}
}

type ConnectionMysqlShardedDefaultUpdateSchedule struct {
	// The pipeline mode refers to how the pipeline fetches data changes from the source and how those changes are applied to the destination table. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjIyMjE3ODA2-introduction">the documentation</a> for more details.
	PipelineMode *PipelineUpdateModes `json:"pipelineMode,omitempty"`
	// The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information. When undefined, the pipeline will default to the schedule set on the source connection.
	UpdateSchedule *UpdateScheduleTypes `json:"updateSchedule,omitempty"`
}

func (o *ConnectionMysqlShardedDefaultUpdateSchedule) GetPipelineMode() *PipelineUpdateModes {
	if o == nil {
		return nil
	}
	return o.PipelineMode
}

func (o *ConnectionMysqlShardedDefaultUpdateSchedule) GetUpdateSchedule() *UpdateScheduleTypes {
	if o == nil {
		return nil
	}
	return o.UpdateSchedule
}

func (o *ConnectionMysqlShardedDefaultUpdateSchedule) GetUpdateScheduleMonthly() *UpdateScheduleModeMonthly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeMonthly
	}
	return nil
}

func (o *ConnectionMysqlShardedDefaultUpdateSchedule) GetUpdateScheduleHourly() *UpdateScheduleModeHourly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeHourly
	}
	return nil
}

func (o *ConnectionMysqlShardedDefaultUpdateSchedule) GetUpdateScheduleInterval() *UpdateScheduleModeInterval {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeInterval
	}
	return nil
}

func (o *ConnectionMysqlShardedDefaultUpdateSchedule) GetUpdateScheduleDaily() *UpdateScheduleModeDaily {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeDaily
	}
	return nil
}

func (o *ConnectionMysqlShardedDefaultUpdateSchedule) GetUpdateScheduleWeekly() *UpdateScheduleModeWeekly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeWeekly
	}
	return nil
}

type ConnectionMysqlShardedType string

const (
	ConnectionMysqlShardedTypeMysqlSharded ConnectionMysqlShardedType = "MYSQL_SHARDED"
)

func (e ConnectionMysqlShardedType) ToPointer() *ConnectionMysqlShardedType {
	return &e
}

func (e *ConnectionMysqlShardedType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MYSQL_SHARDED":
		*e = ConnectionMysqlShardedType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConnectionMysqlShardedType: %v", v)
	}
}

// ConnectionMysqlShardedOutput - The properties available shared among both sharded and unsharded versions. Cannot be used directly; use the inheriting classes.
type ConnectionMysqlShardedOutput struct {
	// The current status of the connection.
	Status ConnectionMysqlShardedStatus `json:"status"`
	// The unique name of this connection.
	Name string `json:"name"`
	// The date and time when then the connection was created.
	CreateDate time.Time `json:"createDate"`
	// When an update schedule is not defined for a connection, the default schedule is used. The default defined individually per `pipelineMode` and may be subject to change.
	DefaultUpdateSchedule []ConnectionMysqlShardedDefaultUpdateSchedule `json:"defaultUpdateSchedule"`
	// Whether this connection has been marked as active.
	Active bool                       `json:"active"`
	Type   ConnectionMysqlShardedType `json:"type"`
	// The unique identifier of the connection.
	ID string `json:"id"`
	// The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information. When undefined, the pipeline will default to the schedule set on the source connection.
	UpdateSchedule *UpdateScheduleTypes `json:"updateSchedule,omitempty"`
	// The TLS certificate used to verify the server's identity and encrypt data in transit. If not specified, the AWS RDS global certificate bundle will be used. Should only be specified if `requireSslAndValidateCertificate` is set to `true`.
	Certificate *string `json:"certificate,omitempty"`
	// Deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
	Database *string `json:"database,omitempty"`
	// If you want Etleap to create pipelines for each source table automatically, specify the id of an Etleap destination connection here. If you want to create pipelines manually, omit this property.<br/><br/>If a database is not specified on this connection, then all databases will be replicated to the selected destination. Any databases not present in the destination will be created as needed.<br/><br/>If a database is specified on this connection, then only tables in that database will be replicated to the selected destination. Tables will be created in the database specified on the destination connection.
	AutoReplicate                    *string `json:"autoReplicate,omitempty"`
	RequireSslAndValidateCertificate *bool   `default:"true" json:"requireSslAndValidateCertificate"`
	// Should Etleap interpret columns with type Tinyint(1) as Boolean (i.e. true/false)?
	TinyInt1IsBoolean *bool `default:"false" json:"tinyInt1IsBoolean"`
	// Should Etleap use MySQL binlogs to capture changes from this database? This setting cannot be changed later.
	CdcEnabled *bool `default:"false" json:"cdcEnabled"`
	// All MySQL shards for a connection should specify the same database.
	Shards []MysqlShardOutput `json:"shards"`
}

func (c ConnectionMysqlShardedOutput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ConnectionMysqlShardedOutput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ConnectionMysqlShardedOutput) GetStatus() ConnectionMysqlShardedStatus {
	if o == nil {
		return ConnectionMysqlShardedStatus("")
	}
	return o.Status
}

func (o *ConnectionMysqlShardedOutput) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ConnectionMysqlShardedOutput) GetCreateDate() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreateDate
}

func (o *ConnectionMysqlShardedOutput) GetDefaultUpdateSchedule() []ConnectionMysqlShardedDefaultUpdateSchedule {
	if o == nil {
		return []ConnectionMysqlShardedDefaultUpdateSchedule{}
	}
	return o.DefaultUpdateSchedule
}

func (o *ConnectionMysqlShardedOutput) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *ConnectionMysqlShardedOutput) GetType() ConnectionMysqlShardedType {
	if o == nil {
		return ConnectionMysqlShardedType("")
	}
	return o.Type
}

func (o *ConnectionMysqlShardedOutput) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ConnectionMysqlShardedOutput) GetUpdateSchedule() *UpdateScheduleTypes {
	if o == nil {
		return nil
	}
	return o.UpdateSchedule
}

func (o *ConnectionMysqlShardedOutput) GetUpdateScheduleMonthly() *UpdateScheduleModeMonthly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeMonthly
	}
	return nil
}

func (o *ConnectionMysqlShardedOutput) GetUpdateScheduleHourly() *UpdateScheduleModeHourly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeHourly
	}
	return nil
}

func (o *ConnectionMysqlShardedOutput) GetUpdateScheduleInterval() *UpdateScheduleModeInterval {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeInterval
	}
	return nil
}

func (o *ConnectionMysqlShardedOutput) GetUpdateScheduleDaily() *UpdateScheduleModeDaily {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeDaily
	}
	return nil
}

func (o *ConnectionMysqlShardedOutput) GetUpdateScheduleWeekly() *UpdateScheduleModeWeekly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeWeekly
	}
	return nil
}

func (o *ConnectionMysqlShardedOutput) GetCertificate() *string {
	if o == nil {
		return nil
	}
	return o.Certificate
}

func (o *ConnectionMysqlShardedOutput) GetDatabase() *string {
	if o == nil {
		return nil
	}
	return o.Database
}

func (o *ConnectionMysqlShardedOutput) GetAutoReplicate() *string {
	if o == nil {
		return nil
	}
	return o.AutoReplicate
}

func (o *ConnectionMysqlShardedOutput) GetRequireSslAndValidateCertificate() *bool {
	if o == nil {
		return nil
	}
	return o.RequireSslAndValidateCertificate
}

func (o *ConnectionMysqlShardedOutput) GetTinyInt1IsBoolean() *bool {
	if o == nil {
		return nil
	}
	return o.TinyInt1IsBoolean
}

func (o *ConnectionMysqlShardedOutput) GetCdcEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.CdcEnabled
}

func (o *ConnectionMysqlShardedOutput) GetShards() []MysqlShardOutput {
	if o == nil {
		return []MysqlShardOutput{}
	}
	return o.Shards
}

// ConnectionMysqlSharded - The properties available shared among both sharded and unsharded versions. Cannot be used directly; use the inheriting classes.
type ConnectionMysqlSharded struct {
	// The unique name of this connection.
	Name string                     `json:"name"`
	Type ConnectionMysqlShardedType `json:"type"`
	// The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information. When undefined, the pipeline will default to the schedule set on the source connection.
	UpdateSchedule *UpdateScheduleTypes `json:"updateSchedule,omitempty"`
	// The TLS certificate used to verify the server's identity and encrypt data in transit. If not specified, the AWS RDS global certificate bundle will be used. Should only be specified if `requireSslAndValidateCertificate` is set to `true`.
	Certificate *string `json:"certificate,omitempty"`
	// Deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
	Database *string `json:"database,omitempty"`
	// If you want Etleap to create pipelines for each source table automatically, specify the id of an Etleap destination connection here. If you want to create pipelines manually, omit this property.<br/><br/>If a database is not specified on this connection, then all databases will be replicated to the selected destination. Any databases not present in the destination will be created as needed.<br/><br/>If a database is specified on this connection, then only tables in that database will be replicated to the selected destination. Tables will be created in the database specified on the destination connection.
	AutoReplicate                    *string `json:"autoReplicate,omitempty"`
	RequireSslAndValidateCertificate *bool   `default:"true" json:"requireSslAndValidateCertificate"`
	// Should Etleap interpret columns with type Tinyint(1) as Boolean (i.e. true/false)?
	TinyInt1IsBoolean *bool `default:"false" json:"tinyInt1IsBoolean"`
	// Should Etleap use MySQL binlogs to capture changes from this database? This setting cannot be changed later.
	CdcEnabled *bool `default:"false" json:"cdcEnabled"`
	// All MySQL shards for a connection should specify the same database.
	Shards []MysqlShard `json:"shards"`
}

func (c ConnectionMysqlSharded) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ConnectionMysqlSharded) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ConnectionMysqlSharded) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ConnectionMysqlSharded) GetType() ConnectionMysqlShardedType {
	if o == nil {
		return ConnectionMysqlShardedType("")
	}
	return o.Type
}

func (o *ConnectionMysqlSharded) GetUpdateSchedule() *UpdateScheduleTypes {
	if o == nil {
		return nil
	}
	return o.UpdateSchedule
}

func (o *ConnectionMysqlSharded) GetUpdateScheduleMonthly() *UpdateScheduleModeMonthly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeMonthly
	}
	return nil
}

func (o *ConnectionMysqlSharded) GetUpdateScheduleHourly() *UpdateScheduleModeHourly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeHourly
	}
	return nil
}

func (o *ConnectionMysqlSharded) GetUpdateScheduleInterval() *UpdateScheduleModeInterval {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeInterval
	}
	return nil
}

func (o *ConnectionMysqlSharded) GetUpdateScheduleDaily() *UpdateScheduleModeDaily {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeDaily
	}
	return nil
}

func (o *ConnectionMysqlSharded) GetUpdateScheduleWeekly() *UpdateScheduleModeWeekly {
	if v := o.GetUpdateSchedule(); v != nil {
		return v.UpdateScheduleModeWeekly
	}
	return nil
}

func (o *ConnectionMysqlSharded) GetCertificate() *string {
	if o == nil {
		return nil
	}
	return o.Certificate
}

func (o *ConnectionMysqlSharded) GetDatabase() *string {
	if o == nil {
		return nil
	}
	return o.Database
}

func (o *ConnectionMysqlSharded) GetAutoReplicate() *string {
	if o == nil {
		return nil
	}
	return o.AutoReplicate
}

func (o *ConnectionMysqlSharded) GetRequireSslAndValidateCertificate() *bool {
	if o == nil {
		return nil
	}
	return o.RequireSslAndValidateCertificate
}

func (o *ConnectionMysqlSharded) GetTinyInt1IsBoolean() *bool {
	if o == nil {
		return nil
	}
	return o.TinyInt1IsBoolean
}

func (o *ConnectionMysqlSharded) GetCdcEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.CdcEnabled
}

func (o *ConnectionMysqlSharded) GetShards() []MysqlShard {
	if o == nil {
		return []MysqlShard{}
	}
	return o.Shards
}
