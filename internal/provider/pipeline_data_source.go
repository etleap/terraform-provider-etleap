// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"github.com/etleap/terraform-provider-etleap/internal/sdk"
	"github.com/etleap/terraform-provider-etleap/internal/sdk/pkg/models/operations"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &PipelineDataSource{}
var _ datasource.DataSourceWithConfigure = &PipelineDataSource{}

func NewPipelineDataSource() datasource.DataSource {
	return &PipelineDataSource{}
}

// PipelineDataSource is the data source implementation.
type PipelineDataSource struct {
	client *sdk.SDK
}

// PipelineDataSourceModel describes the data model.
type PipelineDataSourceModel struct {
	CreateDate            types.String                         `tfsdk:"create_date"`
	Destinations          []DestinationInfoAndPipelineVersions `tfsdk:"destinations"`
	ID                    types.String                         `tfsdk:"id"`
	LastRefreshFinishDate types.String                         `tfsdk:"last_refresh_finish_date"`
	LastRefreshStartDate  types.String                         `tfsdk:"last_refresh_start_date"`
	Latency               types.Int64                          `tfsdk:"latency"`
	LatestScriptVersion   types.Int64                          `tfsdk:"latest_script_version"`
	Name                  types.String                         `tfsdk:"name"`
	Owner                 User                                 `tfsdk:"owner"`
	ParsingErrorSettings  *ParsingErrorSettings                `tfsdk:"parsing_error_settings"`
	Paused                types.Bool                           `tfsdk:"paused"`
	PipelineMode          types.String                         `tfsdk:"pipeline_mode"`
	RefreshSchedule       RefreshScheduleTypes                 `tfsdk:"refresh_schedule"`
	Shares                []types.String                       `tfsdk:"shares"`
	Source                SourceTypes                          `tfsdk:"source"`
	StopReason            types.String                         `tfsdk:"stop_reason"`
	UpdateSchedule        *UpdateScheduleTypes                 `tfsdk:"update_schedule"`
}

// Metadata returns the data source type name.
func (r *PipelineDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_pipeline"
}

// Schema defines the schema for the data source.
func (r *PipelineDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Pipeline DataSource",

		Attributes: map[string]schema.Attribute{
			"create_date": schema.StringAttribute{
				Computed:    true,
				Description: `The date and time when then the pipeline was created.`,
			},
			"destinations": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"current_version": schema.Int64Attribute{
							Computed:    true,
							Description: `The version of the pipeline that is currently writing to the output table.`,
						},
						"destination": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"delta_lake": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"automatic_schema_changes": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `.`,
										},
										"connection_id": schema.StringAttribute{
											Computed:    true,
											Description: `The universally unique identifier of the destination connection.`,
										},
										"last_updated_column": schema.StringAttribute{
											Computed:    true,
											Description: `Name of a column that indicates the time the record was updated at the destination.`,
										},
										"pre10_dot2_runtime_support": schema.BoolAttribute{
											Computed: true,
											MarkdownDescription: `This setting disables column mapping on the tables created by this pipeline.` + "\n" +
												`` + "\n" +
												`When enabled, this pipeline will create Delta Lake tables that can be read by Databricks clusters with runtime versions before 10.2.` + "\n" +
												`` + "\n" +
												`However, without column mapping, native schema changes are not supported and will cause the table's underlying Parquet files to be rewritten, which can be slow. Schema changes will also not preserve column constraints such as ` + "`" + `NOT NULL` + "`" + ` on the destination tables.`,
										},
										"primary_key": schema.ListAttribute{
											Computed:    true,
											ElementType: types.StringType,
											Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier.`,
										},
										"retain_history": schema.BoolAttribute{
											Computed:    true,
											Description: `If the destination table should retain the history of the source. More information here: https://docs.etleap.com/docs/documentation/56a1503dc499e-update-with-history-retention-mode. Defaults to ` + "`" + `false` + "`" + `.`,
										},
										"schema": schema.StringAttribute{
											Computed:    true,
											Description: `The schema in the destination that the tables will be created in.`,
										},
										"table": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["DELTA_LAKE"]`,
										},
										"wait_for_quality_check": schema.BoolAttribute{
											Computed:    true,
											Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `.`,
										},
									},
								},
								"iceberg": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"automatic_schema_changes": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `.`,
										},
										"connection_id": schema.StringAttribute{
											Computed:    true,
											Description: `The universally unique identifier of the destination connection.`,
										},
										"primary_key": schema.ListAttribute{
											Computed:    true,
											ElementType: types.StringType,
											Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier.`,
										},
										"schema": schema.StringAttribute{
											Computed:    true,
											Description: `The schema in the destination that the tables will be created in. If this is not specified or set to ` + "`" + `null` + "`" + ` then the schema specified on the connection is used.`,
										},
										"table": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["ICEBERG"]`,
										},
										"wait_for_quality_check": schema.BoolAttribute{
											Computed:    true,
											Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `.`,
										},
									},
								},
								"redshift": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"automatic_schema_changes": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `.`,
										},
										"compress_columns": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether columns should be compressed. Defaults to ` + "`" + `true` + "`" + `.`,
										},
										"connection_id": schema.StringAttribute{
											Computed:    true,
											Description: `The universally unique identifier of the destination connection.`,
										},
										"distribution_style": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"one": schema.StringAttribute{
													Computed:    true,
													Description: `must be one of ["ALL", "AUTO", "EVEN"]`,
												},
												"distribution_style_key": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"column": schema.StringAttribute{
															Computed: true,
														},
														"type": schema.StringAttribute{
															Computed:    true,
															Description: `must be one of ["KEY"]`,
														},
													},
												},
											},
											Description: `Can either be one the strings ` + "`" + `ALL` + "`" + `, ` + "`" + `AUTO` + "`" + ` or ` + "`" + `EVEN` + "`" + `, or an object for ` + "`" + `KEY` + "`" + ` distribution that specifies a column.`,
										},
										"last_updated_column": schema.StringAttribute{
											Computed:    true,
											Description: `Name of a column that indicates the time the record was updated at the destination.`,
										},
										"primary_key": schema.ListAttribute{
											Computed:    true,
											ElementType: types.StringType,
											Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier.`,
										},
										"retain_history": schema.BoolAttribute{
											Computed:    true,
											Description: `If the destination table should retain the history of the source. More information here: https://docs.etleap.com/docs/documentation/56a1503dc499e-update-with-history-retention-mode. Defaults to ` + "`" + `false` + "`" + `.`,
										},
										"schema": schema.StringAttribute{
											Computed:    true,
											Description: `The schema in the destination that the tables will be created in. If this is not specified or set to ` + "`" + `null` + "`" + ` then the schema specified on the connection is used.`,
										},
										"sort_columns": schema.ListAttribute{
											Computed:    true,
											ElementType: types.StringType,
											Description: `The sort columns to use.`,
										},
										"table": schema.StringAttribute{
											Computed: true,
										},
										"truncate_strings": schema.BoolAttribute{
											Computed:    true,
											Description: `Truncate strings to 64K characters, the max allowed by Redshift in a single column. Defaults to ` + "`" + `false` + "`" + `.`,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["REDSHIFT"]`,
										},
										"wait_for_quality_check": schema.BoolAttribute{
											Computed:    true,
											Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `.`,
										},
									},
								},
								"s3_data_lake": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"automatic_schema_changes": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `.`,
										},
										"connection_id": schema.StringAttribute{
											Computed:    true,
											Description: `The universally unique identifier of the destination connection.`,
										},
										"generate_snapshots": schema.BoolAttribute{
											Computed:    true,
											Description: `Defaults to 'false'.`,
										},
										"output_format": schema.StringAttribute{
											Computed:    true,
											Description: `Format for output files. Defaults to ` + "`" + `PARQUET` + "`" + `. For Glue-enabled destinations, only ` + "`" + `PARQUET` + "`" + ` is a valid format. must be one of ["PARQUET", "CSV"]`,
										},
										"path_prefix": schema.StringAttribute{
											Computed:    true,
											Description: `The S3 path prefix to use for this pipeline. The data key in the destination bucket starts with ` + "`" + `{connection.pathPrefix}/{pathPrefix}/v{version.pipeline}/` + "`" + `.`,
										},
										"primary_key": schema.ListAttribute{
											Computed:    true,
											ElementType: types.StringType,
											Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier.`,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["S3_DATA_LAKE"]`,
										},
										"wait_for_quality_check": schema.BoolAttribute{
											Computed:    true,
											Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `.`,
										},
									},
								},
								"snowflake": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"automatic_schema_changes": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `.`,
										},
										"clustering_keys": schema.ListAttribute{
											Computed:    true,
											ElementType: types.StringType,
											Description: `Keys to cluster the table on. If unspecified, the table will use "automatic clustering".`,
										},
										"connection_id": schema.StringAttribute{
											Computed:    true,
											Description: `The universally unique identifier of the destination connection.`,
										},
										"last_updated_column": schema.StringAttribute{
											Computed:    true,
											Description: `Name of a column that indicates the time the record was updated at the destination.`,
										},
										"primary_key": schema.ListAttribute{
											Computed:    true,
											ElementType: types.StringType,
											Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier.`,
										},
										"retain_history": schema.BoolAttribute{
											Computed:    true,
											Description: `If the destination table should retain the history of the source. More information here: https://docs.etleap.com/docs/documentation/56a1503dc499e-update-with-history-retention-mode. Defaults to ` + "`" + `false` + "`" + `.`,
										},
										"schema": schema.StringAttribute{
											Computed:    true,
											Description: `The schema in the destination that the tables will be created in. If this is not specified or set to ` + "`" + `null` + "`" + ` then the schema specified on the connection is used.`,
										},
										"table": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["SNOWFLAKE"]`,
										},
										"wait_for_quality_check": schema.BoolAttribute{
											Computed:    true,
											Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `.`,
										},
									},
								},
							},
						},
						"parsing_errors": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"operation_errors_by_operation": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"operation_description": schema.StringAttribute{
												Computed: true,
											},
											"operation_index": schema.Int64Attribute{
												Computed:    true,
												Description: `Index of step in the script of this pipeline that caused this error.`,
											},
											"row_count": schema.Int64Attribute{
												Computed: true,
											},
										},
									},
								},
								"parsing_errors_per_day": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"day": schema.StringAttribute{
												Computed:    true,
												Description: `Format of the timestamp: 'yyyy-MM-dd'`,
											},
											"error_type": schema.StringAttribute{
												Computed:    true,
												Description: `must be one of ["TYPE", "OPERATION"]`,
											},
											"row_count": schema.Int64Attribute{
												Computed: true,
											},
										},
									},
								},
								"type_errors_by_column": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"column_name": schema.StringAttribute{
												Computed: true,
											},
											"row_count": schema.Int64Attribute{
												Computed: true,
											},
											"type": schema.StringAttribute{
												Computed: true,
											},
										},
									},
								},
							},
							Description: `Parsing errors that occur during the transformation of the pipeline. If a pipeline is being refreshed, these errors will be for the refreshing pipeline.`,
						},
						"refresh_version": schema.Int64Attribute{
							Computed:    true,
							Description: `The version of the pipeline that is currently writing to the temporary refresh table. Only specified if there's currently a refresh in progress.`,
						},
						"retention_data": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"retention_by_day": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"rows_currently_in_warehouse": schema.ListNestedAttribute{
											Computed: true,
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"date": schema.StringAttribute{
														Computed:    true,
														Description: `Format of the timestamp: 'yyyy-MM-dd'`,
													},
													"row_count": schema.Int64Attribute{
														Computed: true,
													},
												},
											},
										},
										"rows_removed_from_warehouse": schema.ListNestedAttribute{
											Computed: true,
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"date": schema.StringAttribute{
														Computed:    true,
														Description: `Format of the timestamp: 'yyyy-MM-dd'`,
													},
													"row_count": schema.Int64Attribute{
														Computed: true,
													},
												},
											},
										},
									},
								},
								"retention_policy": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"column": schema.StringAttribute{
											Computed:    true,
											Description: `Name of the column that is used to calculate the interval. Must be a ` + "`" + `date` + "`" + ` or a ` + "`" + `datetime` + "`" + ` column.`,
										},
										"period": schema.Int64Attribute{
											Computed:    true,
											Description: `Number of days before a row gets removed.`,
										},
									},
									Description: `Policy for the automatic deletion of rows in the destination.`,
								},
							},
							Description: `Etleap can remove old rows from your destination. This is a summary of the data retention. If a pipeline is being refreshed, this will be the summary for the refreshing pipeline.`,
						},
						"schema_change_activity": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"date_time": schema.StringAttribute{
										Computed:    true,
										Description: `The date and time of the schema change. ` + "`" + `null` + "`" + ` if schema change has not yet been applied.`,
									},
									"schema_change_description": schema.StringAttribute{
										Computed: true,
									},
								},
							},
							Description: `Array of schema change objects. If a pipeline is being refreshed, the schema change activities will be for the refreshing pipeline.`,
						},
					},
				},
				Description: `A pipeline may have multiple destinations if it is in the process of being migrated from one to another.`,
			},
			"id": schema.StringAttribute{
				Required: true,
			},
			"last_refresh_finish_date": schema.StringAttribute{
				Computed:    true,
				Description: `The date and time when the last refresh finished. ` + "`" + `null` + "`" + ` if the pipeline was never refreshed.`,
			},
			"last_refresh_start_date": schema.StringAttribute{
				Computed:    true,
				Description: `The date and time when the last refresh was started. ` + "`" + `null` + "`" + ` if the pipeline was never refreshed.`,
			},
			"latency": schema.Int64Attribute{
				Computed:    true,
				Description: `The end-to-end latency in seconds for this pipeline. Not ` + "`" + `null` + "`" + ` if the pipeline is running (not paused or stopped) and if the initial backfill has finished. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjIyMTU3NTQ3-latency#end-to-end-latency">the documentation</a> for more details.`,
			},
			"latest_script_version": schema.Int64Attribute{
				Computed:    true,
				Description: `Valid script versions are whole numbers and range from 1 to this number.`,
			},
			"name": schema.StringAttribute{
				Computed: true,
			},
			"owner": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"email_address": schema.StringAttribute{
						Computed: true,
					},
					"first_name": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"last_name": schema.StringAttribute{
						Computed: true,
					},
				},
			},
			"parsing_error_settings": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"action": schema.StringAttribute{
						Computed:    true,
						Description: `Whether Etleap should STOP the pipeline or NOTIFY once the ` + "`" + `threshold` + "`" + ` is reached. must be one of ["STOP", "NOTIFY"]`,
					},
					"threshold": schema.NumberAttribute{
						Computed:    true,
						Description: `The parsing error threshold, in percentage points, for the ` + "`" + `action` + "`" + ` to be triggered.`,
					},
				},
			},
			"paused": schema.BoolAttribute{
				Computed:    true,
				Description: `If the pipeline is paused. Defaults to ` + "`" + `false` + "`" + `.`,
			},
			"pipeline_mode": schema.StringAttribute{
				Computed:    true,
				Description: `The pipeline mode refers to how the pipeline fetches data changes from the source and how those changes are applied to the destination table. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjIyMjE3ODA2-introduction">the documentation</a> for more details. must be one of ["APPEND", "REPLACE", "UPDATE", "QUERY"]`,
			},
			"refresh_schedule": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"daily": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"hour_of_day": schema.Int64Attribute{
								Computed:    true,
								Description: `Hour of day this schedule should trigger at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["DAILY"]`,
							},
						},
					},
					"hourly": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["HOURLY"]`,
							},
						},
					},
					"monthly": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"day_of_month": schema.Int64Attribute{
								Computed:    true,
								Description: `Day of the month this schedule should trigger at (in UTC).`,
							},
							"hour_of_day": schema.Int64Attribute{
								Computed:    true,
								Description: `Hour of day this schedule should trigger at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["MONTHLY"]`,
							},
						},
					},
					"never": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["NEVER"]`,
							},
						},
					},
					"weekly": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"day_of_week": schema.Int64Attribute{
								Computed:    true,
								Description: `The day of the week this schedule should trigger at (in UTC).`,
							},
							"hour_of_day": schema.Int64Attribute{
								Computed:    true,
								Description: `Hour of day this schedule should trigger at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["WEEKLY"]`,
							},
						},
					},
				},
				Description: `A pipeline refresh processes all data in your source from the beginning to re-establish consistency with your destination. The pipeline refresh schedule defines when Etleap should automatically refresh the pipeline. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.`,
			},
			"shares": schema.ListAttribute{
				Computed:    true,
				ElementType: types.StringType,
				MarkdownDescription: `A list of users' emails this pipeline is shared with.` + "\n" +
					`` + "\n" +
					`A pipeline cannot be unshared, and future calls to ` + "`" + `PATCH` + "`" + ` can only add to this list.`,
			},
			"source": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"active_campaign": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The ActiveCampaign resource. Example: Contacts, Custom Fields and Custom Values`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["ACTIVE_CAMPAIGN"]`,
							},
						},
					},
					"bigquery": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"dataset": schema.StringAttribute{
								Computed:    true,
								Description: `Name of dataset in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["BIGQUERY"]`,
							},
						},
					},
					"bing_ads": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The report type.`,
							},
							"fields": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `The field names.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["BING_ADS"]`,
							},
						},
					},
					"blackline": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Blackline report name. Example: Account Details Extract Template`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["BLACKLINE"]`,
							},
						},
					},
					"braintree": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Braintree entity.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["BRAINTREE"]`,
							},
						},
					},
					"confluent_cloud": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `You can ingest data from Kafka topics in your Confluent Cloud cluster.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["CONFLUENT_CLOUD"]`,
							},
						},
					},
					"coupa": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Coupa resource. Example: Approvals, Items, Suppliers.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["COUPA"]`,
							},
						},
					},
					"criteo": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"currency": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `currency` + "`" + ` if and only if the entity is 'report_placement', 'report_statistics' or 'report_transactions'. Example values: [USD, EUR]`,
							},
							"dimensions": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `dimension` + "`" + ` if and only if the entity is 'report_placement' or 'report_statistics'. Example values: [Day, advertiserId, adsetId]`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Criteo resource. Example: ad_set, advertiser, audience, campaign, report_placement, report_statistics, and report_transactions.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"metrics": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `metric` + "`" + ` if and only if the entity is 'report_placement' or 'report_statistics'. Example values: [clicks, displays]`,
							},
							"timezone": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `timezone` + "`" + ` if and only if the entity is 'report_placement' or 'report_transactions'. Example values: [UTC, ETC/GMT-3]`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["CRITEO"]`,
							},
						},
					},
					"db2": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["DB2"]`,
							},
						},
					},
					"db2_sharded": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["DB2_SHARDED"]`,
							},
						},
					},
					"delta_lake": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["DELTA_LAKE"]`,
							},
						},
					},
					"egnyte": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Excel resource path on egnyte. e.g. "/Shared/Documents/data.xlsx" or  "/Shared/Documents/data.xlsx/sheet_1"`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["EGNYTE"]`,
							},
						},
					},
					"elasticsearch": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The index name.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["ELASTICSEARCH"]`,
							},
						},
					},
					"elluminate": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"domain_name": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `The Domain that you want to extract from. If no domain is specified Etleap will extract data from all schema's domains. `,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Elluminate study name.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"schema_name": schema.StringAttribute{
								Computed:    true,
								Description: `The Schema that you want to extract from.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["ELLUMINATE"]`,
							},
						},
					},
					"eloqua": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Eloqua resource, spelled as it is shown in the Eloqua UI. Each ActivityType is a different entity and is spelled without spaces like EmailClickthrough and EmailSend.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["ELOQUA"]`,
							},
						},
					},
					"erpx": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The ERPx resource.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["ERPX"]`,
							},
						},
					},
					"facebook_ads": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"breakdowns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `The breakdown fields. The first one must be ` + "`" + `date_start` + "`" + `. See the [Facebook Documentation on Breakdowns.](https://developers.facebook.com/docs/marketing-api/insights/breakdowns/v21.0#insights-api-breakdowns)`,
							},
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The aggregation level of the Facebook report. Example values: [Insights by Ad, Insights by Adset, Insights by Campaign, Insights by Account]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["FACEBOOK_ADS"]`,
							},
						},
					},
					"fifteen_five": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The 15Five entity. Example values: [answer, report, department, feature-status, group-type, group, high-five, objective_objective_id_history, objective, attribute_value, attribute, priority, question, security-audit, vacation, user]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["FIFTEEN_FIVE"]`,
							},
						},
					},
					"freshchat": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Freshchat resource. Example values: [Agents, Channels, Conversations, Conversation Messages]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["FRESHCHAT"]`,
							},
							"view": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Only when Entity is related to Deals. Select which views you want Etleap to pull data from.`,
							},
						},
					},
					"freshsales": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Freshsales resource. Example values: [Leads, Deals, Appointments or Tasks]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["FRESHSALES"]`,
							},
							"view": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Only when Entity is related to Deals. Select which views you want Etleap to pull data from.`,
							},
						},
					},
					"freshworks": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed: true,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["FRESHWORKS"]`,
							},
						},
					},
					"ftp": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"file_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching the names of the files to be processed by this pipeline. A single value for ` + "`" + `paths` + "`" + ` is required when ` + "`" + `fileNameFilter` + "`" + ` is specified.`,
							},
							"glob_pattern": schema.StringAttribute{
								Computed:    true,
								Description: `A glob pattern to be used as a path. Either ` + "`" + `globPattern` + "`" + ` or ` + "`" + `paths` + "`" + ` must be specified, but not both.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"low_watermark": schema.StringAttribute{
								Computed:    true,
								Description: `Timestamp of the earliest modified file that should be processed by the pipeline. Only the files modified after this timestamp will be processed. Format of the timestamp: 'yyyy-MM-dd'.`,
							},
							"new_file_behavior": schema.StringAttribute{
								Computed:    true,
								Description: `Specifies whether new files update, add to or replace existing files. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjI0NTQwNzI2-create-a-file-based-pipeline#update-method">the documentation</a> for more details. must be one of ["UPDATE", "APPEND", "REPLACE"]`,
							},
							"paths": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `File or folder paths for the files to be extracted from the source. In the case when ` + "`" + `fileNameFilter` + "`" + ` is specified exactly one folder path must be given here. ` + "`" + `paths` + "`" + ` can't be used when a ` + "`" + `globPattern` + "`" + ` is specified.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["FTP"]`,
							},
						},
					},
					"gong": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Gong resource. Example values: [Answered Scorecards, Call Transcripts, Calls, Calls Extensive, Folders, Interactions, Scorecards, Users, Users Activity, Users Extensive, Workspaces]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["GONG"]`,
							},
						},
					},
					"google_ads": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"attributed_resources": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `attributed resources` + "`" + `. Example values: [campaign_budget.id, campaign_budget.name, bidding_strategy.type]`,
							},
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Google Ads report type, capitalized and spelled with spaces between words.`,
							},
							"fields": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `fields` + "`" + `. Example values: [campaign.resource_name, campaign.campaign_budget, campaign.advertising_channel_type]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"metrics": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `metrics` + "`" + `. Example values: [metrics.clicks, metrics.all_conversions, metrics.average_cost]`,
							},
							"segments": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `segmentation` + "`" + ` groups. Example values: [segments.date, segments.click_type, segments.geo_target_county]`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["GOOGLE_ADS"]`,
							},
						},
					},
					"google_analytics_ga4": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"dimensions": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Dimensions are attributes for your data. Example values: [date, browser].`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Google Analytics GA4 resource. Provide the ID of the GA4 resource. You can find out how to retrieve the ID of you resource <a href='https://developers.google.com/analytics/devguides/reporting/data/v1/property-id'>here</a>.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"metrics": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Metrics represent quantitative measurements calculated by Google Analytics. Example values: [active1DayUsers, conversions]`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["GOOGLE_ANALYTICS_GA4"]`,
							},
						},
					},
					"google_cloud_storage": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"file_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching the names of the files to be processed by this pipeline. A single value for ` + "`" + `paths` + "`" + ` is required when ` + "`" + `fileNameFilter` + "`" + ` is specified.`,
							},
							"glob_pattern": schema.StringAttribute{
								Computed:    true,
								Description: `A glob pattern to be used as a path. Either ` + "`" + `globPattern` + "`" + ` or ` + "`" + `paths` + "`" + ` must be specified, but not both.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"low_watermark": schema.StringAttribute{
								Computed:    true,
								Description: `Timestamp of the earliest modified file that should be processed by the pipeline. Only the files modified after this timestamp will be processed. Format of the timestamp: 'yyyy-MM-dd'.`,
							},
							"new_file_behavior": schema.StringAttribute{
								Computed:    true,
								Description: `Specifies whether new files update, add to or replace existing files. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjI0NTQwNzI2-create-a-file-based-pipeline#update-method">the documentation</a> for more details. must be one of ["UPDATE", "APPEND", "REPLACE"]`,
							},
							"paths": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `File or folder paths for the files to be extracted from the source. In the case when ` + "`" + `fileNameFilter` + "`" + ` is specified exactly one folder path must be given here. ` + "`" + `paths` + "`" + ` can't be used when a ` + "`" + `globPattern` + "`" + ` is specified.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["GOOGLE_CLOUD_STORAGE"]`,
							},
						},
					},
					"google_sheets": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `Google Sheets entities are in the form ` + "`" + `SpreadsheetID/SheetID` + "`" + `. You can find both values by clicking on the sheet (tab) you want and looking at the URL: docs.google.com/spreadsheets/d/` + "`" + `1pRAGMSRpEEG31kbtG2qcpr-HDeDfvafp_v00` + "`" + `/edit#gid=` + "`" + `642381756` + "`" + ``,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["GOOGLE_SHEETS"]`,
							},
						},
					},
					"hubspot": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Hubspot entity. Example values: [Campaigns, Contacts, Email Events, Engagements, Deals, Owners, Deal Pipelines, Companies, Marketing Emails, Pages, Landing Pages Analytics]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["HUBSPOT"]`,
							},
						},
					},
					"impact_radius": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Impact Radius entity, spelled the same way as in the UI.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["IMPACT_RADIUS"]`,
							},
						},
					},
					"intercom": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Intercom entity. Example values: [User, Lead, Contact, Company, Admin, Tag, Segment, Note, Event, Counts, Conversation Counts, Admin Conversation Counts, User Tags Counts, User Segments Counts, Company Tags Counts, Company Segments Counts, Conversation, Conversation Parts, Conversation Tags, Subscription]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["INTERCOM"]`,
							},
						},
					},
					"jira": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The JIRA entity. Example values: [Issues, Issue Links, Issue Types, Changelog, Comments, Worklogs, Fields, Groups, Group Members, Priorities, Projects, Resolutions, Statuses, Status Categories, Users, Multiple Choice Field]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["JIRA"]`,
							},
						},
					},
					"jira_align": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The JIRA Align entity. Spelled without spaces except for the Audit Logs. Example values: [Capabilities, Cities, Customers, Defects, Epics, Epics Audit Logs, Features, Features Audit Logs, Goals, Ideas, Iterations, KeyResults, Milestones, Milestones Audit Logs, Objectives, Objectives Audit Logs, Portfolios, Products, Programs, Regions, ReleaseVehicles, Releases, Snapshots, Stories, Tasks, Teams, Themes, Users, ValueStreams]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["JIRA_ALIGN"]`,
							},
						},
					},
					"jira_cloud": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The JIRA Software Cloud entity.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["JIRA_CLOUD"]`,
							},
						},
					},
					"kafka": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `You can ingest data from Kafka topics.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["KAFKA"]`,
							},
						},
					},
					"kustomer": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Kustomer entity. Example values: [AUDIT_LOGS, BRANDS, BUSINESS_SCHEDULES, CARDS, COMPANIES, CONVERSATION_ATTACHMENTS, CONVERSATION_EVENTS, CONVERSATION_FORWARDS, CONVERSATION_TIMES, CONVERSATIONS, CUSTOM_ATTRIBUTE_METADATA, CUSTOMER_DRAFTS, CUSTOMER_MERGES, CUSTOMERS, KOBJECTS, KLASSES, MESSAGES, NOTES, NOTIFICATIONS, OUTBOUND_ACCOUNTS, QUEUES, SLAS, SATISFACTIONS, SHORTCUTS, SNOOZES, SPAM_SENDERS, TEAM_ROUTING_SETTINGS, TEAMS, USERS]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["KUSTOMER"]`,
							},
						},
					},
					"ldap": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed: true,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["LDAP"]`,
							},
						},
					},
					"ldap_virtual_list_view": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed: true,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["LDAP_VIRTUAL_LIST_VIEW"]`,
							},
						},
					},
					"linked_in_ads": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The LinkedIn resource. Example values: [ACCOUNTS, ACCOUNT_USERS, AD_ANALYTICS, CAMPAIGNS, CAMPAIGN_GROUPS, CONVERSIONS, INSIGHT_TAG_DOMAINS]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"metrics": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `metrics` + "`" + ` if and only if the entity is 'AD_ANALYTICS'. Example values: [dateRange, pivotValues, clicks]`,
							},
							"pivots": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `pivots` + "`" + ` groups if and only if the entity is 'AD_ANALYTICS'. Example values: [ACCOUNT, CAMPAIGN, COMPANY]`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["LINKED_IN_ADS"]`,
							},
						},
					},
					"marketo": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"activity_types": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify ` + "`" + `activityTypes` + "`" + ` if and only if the entity is 'Activities'`,
							},
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Marketo entity type. Example values: [Leads, Activities, Campaigns, Programs, Tags]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["MARKETO"]`,
							},
						},
					},
					"microsoft_entra_id": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Microsoft Entra ID entity.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["MICROSOFT_ENTRA_ID"]`,
							},
						},
					},
					"mixpanel": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `'Raw Data' is the only entity available for Mixpanel.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["MIXPANEL"]`,
							},
						},
					},
					"mongodb": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["MONGODB"]`,
							},
						},
					},
					"mysql": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"database": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the database in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["MYSQL"]`,
							},
						},
					},
					"mysql_sharded": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"database": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the database in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["MYSQL_SHARDED"]`,
							},
						},
					},
					"netsuite": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Netsuite entity. Spelled capitalized without spaces unless you have defined a custom entity in Netsuite with a different capitalization.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["NETSUITE"]`,
							},
						},
					},
					"netsuite_v2": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Netsuite entity. Spelled capitalized with spaces.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["NETSUITE_V2"]`,
							},
						},
					},
					"oracle": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["ORACLE"]`,
							},
						},
					},
					"oracle_sharded": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["ORACLE_SHARDED"]`,
							},
						},
					},
					"outlook": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Outlook entity. Example values: [Messages, Events].`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["OUTLOOK"]`,
							},
						},
					},
					"outreach": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed: true,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["OUTREACH"]`,
							},
						},
					},
					"pinterest_ads": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `metrics` + "`" + ` if and only if the entity is 'reports'. Example values: [SPEND_IN_MICRO_DOLLAR, PAID_IMPRESSION, CPC_IN_MICRO_DOLLAR]`,
							},
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Pinterest Ads resource. Example values: [ad_accounts, ad_groups, ads, campaigns and reports]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"level": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `data level` + "`" + ` if and only if the entity is 'reports'. Example values: [ADVERTISER, CAMPAIGN, AD_GROUP]`,
							},
							"targeting_types": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `targeting types` + "`" + ` if and only if the entity is 'reports'. Example values: [KEYWORD, APPTYPE, LOCATION]`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["PINTEREST_ADS"]`,
							},
						},
					},
					"postgres": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["POSTGRES"]`,
							},
						},
					},
					"postgres_sharded": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["POSTGRES_SHARDED"]`,
							},
						},
					},
					"quora_ads": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The level of aggregation for your Quora Ads data. Example values: [Account, Campaign, Ad Set, Ad]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["QUORA_ADS"]`,
							},
						},
					},
					"rave_medidata": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Rave Medidata entity. Example values: [dataset, study, <study-oid>@-@<form-oid>]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["RAVE_MEDIDATA"]`,
							},
						},
					},
					"recurly": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Recurly entity. Example values: [Account, Account Acquisition, Line Item, Coupon, Coupon Redemption, Credit Payment, Invoice, Measured Unit, Plan, Plan Add-On, Subscription, Transaction]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["RECURLY"]`,
							},
						},
					},
					"redshift": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["REDSHIFT"]`,
							},
						},
					},
					"redshift_sharded": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["REDSHIFT_SHARDED"]`,
							},
						},
					},
					"s3_input": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"file_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching the names of the files to be processed by this pipeline. A single value for ` + "`" + `paths` + "`" + ` is required when ` + "`" + `fileNameFilter` + "`" + ` is specified.`,
							},
							"files_can_change": schema.BoolAttribute{
								Computed:    true,
								Description: `Etleap can check whether files that were already processed have changed. If the file has changed, then Etleap fetches the new file and removes the old file's data in the destination and adds the changed data. <br> This can only be enabled when ` + "`" + `newFileBehavior` + "`" + ` is set to ` + "`" + `APPEND` + "`" + `. Defaults to ` + "`" + `false` + "`" + `.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"low_watermark": schema.StringAttribute{
								Computed:    true,
								Description: `Timestamp of the earliest modified file that should be processed by the pipeline. Only the files modified after this timestamp will be processed. Format of the timestamp: 'yyyy-MM-dd'.`,
							},
							"new_file_behavior": schema.StringAttribute{
								Computed:    true,
								Description: `Specifies whether new files update, add to or replace existing files. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjI0NTQwNzI2-create-a-file-based-pipeline#update-method">the documentation</a> for more details. must be one of ["UPDATE", "APPEND", "REPLACE"]`,
							},
							"paths": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `File or folder paths for the files to be extracted from the source. In the case when ` + "`" + `fileNameFilter` + "`" + ` is specified exactly one folder path must be given here.`,
							},
							"triggered_by_event": schema.BoolAttribute{
								Computed:    true,
								Description: `Whether this source should be triggered by a ` + "`" + `Batch Added` + "`" + ` event (` + "`" + `true` + "`" + `) or Etleap should inspect the source to find new files to process (` + "`" + `false` + "`" + `). Defaults to ` + "`" + `false` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["S3_INPUT"]`,
							},
						},
					},
					"s3_legacy": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"file_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching the names of the files to be processed by this pipeline. A single value for ` + "`" + `paths` + "`" + ` is required when ` + "`" + `fileNameFilter` + "`" + ` is specified.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"low_watermark": schema.StringAttribute{
								Computed:    true,
								Description: `Timestamp of the earliest modified file that should be processed by the pipeline. Only the files modified after this timestamp will be processed. Format of the timestamp: 'yyyy-MM-dd'.`,
							},
							"new_file_behavior": schema.StringAttribute{
								Computed:    true,
								Description: `Specifies whether new files update, add to or replace existing files. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjI0NTQwNzI2-create-a-file-based-pipeline#update-method">the documentation</a> for more details. must be one of ["UPDATE", "APPEND", "REPLACE"]`,
							},
							"paths": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `File or folder paths for the files to be extracted from the source. In the case when ` + "`" + `fileNameFilter` + "`" + ` is specified exactly one folder path must be given here.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["S3_LEGACY"]`,
							},
						},
					},
					"salesforce": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Salesforce table. Spelled capitalized without spaces, unless it is a custom table like ` + "`" + `My_Table__c` + "`" + `.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SALESFORCE"]`,
							},
						},
					},
					"salesforce_marketing_cloud": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Salesforce Marketing Cloud entity. Example Values: [Bounce Event, Campaign, Click Event, Content Area, Data Extension, Data Extension Object, Email, Folders, List Subscriber, Lists, Open Event, Send, Sent Event, Subscribers, Unsub Event]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SALESFORCE_MARKETING_CLOUD"]`,
							},
						},
					},
					"sap_concur": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The SAP Concur entity. Example Values: [ExpenseEntries, Reports, Users]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SAP_CONCUR"]`,
							},
						},
					},
					"sap_hana": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SAP_HANA"]`,
							},
						},
					},
					"sap_hana_sharded": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SAP_HANA_SHARDED"]`,
							},
						},
					},
					"seismic": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Seismic entity. Example values: [Livesend Links, Livesend Link Contents, Livesend Link Members, Livesend Page Views, Users, User Activity]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SEISMIC"]`,
							},
						},
					},
					"service_now": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The ServiceNow entity. Example values: [Task, Problem, Incident]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SERVICE_NOW"]`,
							},
						},
					},
					"sftp": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"file_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching the names of the files to be processed by this pipeline. A single value for ` + "`" + `paths` + "`" + ` is required when ` + "`" + `fileNameFilter` + "`" + ` is specified.`,
							},
							"glob_pattern": schema.StringAttribute{
								Computed:    true,
								Description: `A glob pattern to be used as a path. Either ` + "`" + `globPattern` + "`" + ` or ` + "`" + `paths` + "`" + ` must be specified, but not both.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"low_watermark": schema.StringAttribute{
								Computed:    true,
								Description: `Timestamp of the earliest modified file that should be processed by the pipeline. Only the files modified after this timestamp will be processed. Format of the timestamp: 'yyyy-MM-dd'.`,
							},
							"new_file_behavior": schema.StringAttribute{
								Computed:    true,
								Description: `Specifies whether new files update, add to or replace existing files. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjI0NTQwNzI2-create-a-file-based-pipeline#update-method">the documentation</a> for more details. must be one of ["UPDATE", "APPEND", "REPLACE"]`,
							},
							"paths": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `File or folder paths for the files to be extracted from the source. In the case when ` + "`" + `fileNameFilter` + "`" + ` is specified exactly one folder path must be given here. ` + "`" + `paths` + "`" + ` can't be used when a ` + "`" + `globPattern` + "`" + ` is specified.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SFTP"]`,
							},
						},
					},
					"shopify": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Shopify entity. Spelled with spaces and only first word capitalized. Nested JSON objects are selected by appending the field name. For example, ` + "`" + `Orders fulfillments line items` + "`" + ` has the lineItems field from the ` + "`" + `Order fulfillments` + "`" + ` entity. Start creating a pipeline in the Etleap UI for the full list of entities.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SHOPIFY"]`,
							},
						},
					},
					"skyward": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Skyward entity. Spelled capitalized with spaces. Example Values: [Academic Sessions, Categories, Classes, Courses, Demographics, Enrollments, Grading Periods, Line Items, Orgs, Results, Schools, Students, Teachers, Terms, Users]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SKYWARD"]`,
							},
						},
					},
					"snapchat_ads": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"additional_metrics": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `additional metrics` + "`" + ` if and only if the entity is 'ad_account_report_hourly' or 'ad_account_report_daily'. Example values: [android_installs, attachment_avg_view_time_millis, attachment_frequency]`,
							},
							"breakdown": schema.StringAttribute{
								Computed:    true,
								Description: `Specify the report ` + "`" + `breakdown` + "`" + ` if and only if the entity is 'ad_account_report_hourly' or 'ad_account_report_daily'. Example values: [ad, adsquad, campaign]`,
							},
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Snapchat Ads entity. Example values: [ad, adaccount, ad_account_report_hourly, ad_account_report_daily]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"metrics": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `metrics` + "`" + ` if and only if the entity is 'ad_account_report_hourly' or 'ad_account_report_daily'. Example values: [impressions, swipes, screen_time_millis]`,
							},
							"report_dimension": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `dimension` + "`" + ` groups if and only if the entity is 'ad_account_report_hourly' or 'ad_account_report_daily'. Example values: [country, region, gender]`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SNAPCHAT_ADS"]`,
							},
						},
					},
					"snowflake": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SNOWFLAKE"]`,
							},
						},
					},
					"snowflake_sharded": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SNOWFLAKE_SHARDED"]`,
							},
						},
					},
					"sql_server": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SQL_SERVER"]`,
							},
						},
					},
					"sql_server_sharded": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"last_updated_column": schema.StringAttribute{
								Computed:    true,
								Description: `Name of a column that indicates the time the record was updated at the source.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array.`,
							},
							"schema": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used.`,
							},
							"table": schema.StringAttribute{
								Computed:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both.`,
							},
							"table_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SQL_SERVER_SHARDED"]`,
							},
						},
					},
					"square": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Square entity. Example values: [Catalog, Customers, Loyalty Accounts, Loyalty Events, Loyalty Rewards, Orders, Refunds]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SQUARE"]`,
							},
						},
					},
					"streaming": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"file_name_filter": schema.StringAttribute{
								Computed:    true,
								Description: `Regular expression matching the names of the files to be processed by this pipeline. A single value for ` + "`" + `paths` + "`" + ` is required when ` + "`" + `fileNameFilter` + "`" + ` is specified.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"low_watermark": schema.StringAttribute{
								Computed:    true,
								Description: `Timestamp of the earliest modified file that should be processed by the pipeline. Only the files modified after this timestamp will be processed. Format of the timestamp: 'yyyy-MM-dd'.`,
							},
							"new_file_behavior": schema.StringAttribute{
								Computed:    true,
								Description: `Specifies whether new files update, add to or replace existing files. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjI0NTQwNzI2-create-a-file-based-pipeline#update-method">the documentation</a> for more details. must be one of ["UPDATE", "APPEND", "REPLACE"]`,
							},
							"paths": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `File or folder paths for the files to be extracted from the source. In the case when ` + "`" + `fileNameFilter` + "`" + ` is specified exactly one folder path must be given here.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["STREAMING"]`,
							},
						},
					},
					"stripe": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Stripe entity. Example values: [Subscriptions, Invoice, InvoiceItems, Events]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["STRIPE"]`,
							},
						},
					},
					"sumtotal": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The SumTotal entity. Example values: [Activities, Audiences, Competencies, Domains, Grades, Jobs, Organizations, Skills, Social, Topics, User Activities, User Activities Progress, User Courses, Users]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SUMTOTAL"]`,
							},
						},
					},
					"the_trade_desk": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed: true,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["THE_TRADE_DESK"]`,
							},
						},
					},
					"tik_tok_ads": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"data_level": schema.StringAttribute{
								Computed:    true,
								Description: `Specify the report ` + "`" + `data level` + "`" + ` if and only if the entity is 'REPORT'. Example values: [AUCTION_AD, AUCTION_CAMPAIGN, RESERVATION_AD]`,
							},
							"dimensions": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `dimension` + "`" + ` groups if and only if the entity is 'REPORT'. Example values: [start_time_day, start_time_hour, campaign_id]`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The TikTok Ads resource. Example values: [AD, ADGROUP, ADVERTISER, CAMPAIGN and REPORT]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"metrics": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `metrics` + "`" + ` if and only if the entity is 'REPORT'. Example values: [ad_name, clicks, conversion]`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["TIK_TOK_ADS"]`,
							},
						},
					},
					"twilio": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Twilio entity. Example values: [Calls, Calls summary, Messages, Usage records]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["TWILIO"]`,
							},
						},
					},
					"twitter_ads": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Twitter entity. Example values: [Account, Campaign, Funding Instrument, Line Item, Media Creative, Promoted Tweet, Followers, Tweets Likes, Tweets Quotes, Retweets, Recent Mentions,Tweets, Account Report, Campaign Report, Funding Instrument Report, Line Item Report, Media Creative Report, Promoted Tweet Report]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["TWITTER_ADS"]`,
							},
						},
					},
					"user_defined_api": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The User-Defined API entity.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["USER_DEFINED_API"]`,
							},
						},
					},
					"uservoice": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The UserVoice entity. Example values: [Category, Comment, Feature, Feature Status, Feedback Record, Forum, Forum Invitation, Internal Status, Label, NPS Rating, Note, Permission, Product Area, Score, Segment, Segmented Values, Status, Status Updates, Suggestion, Suggestion Activity Entry, Supporter, Supporter Message, Team, User, VSTS Work Item]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["USERVOICE"]`,
							},
						},
					},
					"veeva": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Veeva Entity name. Example values: [APQR, APQR Item, Action, Activity, Admin Link, Admin Section, Admin Section Controller Code, Answer Library Design, Application Context Selector, Application License Model, Application License Model Field, Application Manifest, Application Provisioner, Application Role]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["VEEVA"]`,
							},
						},
					},
					"verizon_media_dsp": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"dimensions": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"entity": schema.StringAttribute{
								Computed: true,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"metrics": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["VERIZON_MEDIA_DSP"]`,
							},
						},
					},
					"workday_report": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Workday Report name. Spelled the same as Workday UI but all spaces are replaced with underscores.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["WORKDAY_REPORT"]`,
							},
						},
					},
					"workfront": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Workfront entity. Spelled capitalized without spaces. For the full list, start creating a pipeline in the Etleap UI.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["WORKFRONT"]`,
							},
						},
					},
					"zendesk": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Zendesk entity. Example values: [Group Memberships, Groups, Macros, Organizations, Satisfaction Ratings, SLA Policies, Tags, Ticket Audits, Ticket Comments, Ticket Fields, Ticket Forms, Tickets, Ticket Metrics, Users]`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["ZENDESK"]`,
							},
						},
					},
					"zoom_phone": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed: true,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["ZOOM_PHONE"]`,
							},
						},
					},
					"zuora": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed:    true,
								Description: `The universally unique identifier for the source.`,
							},
							"entity": schema.StringAttribute{
								Computed:    true,
								Description: `The Zuora entity. Spelled capitalized with spaces. For the full list, start creating a pipeline in the Etleap UI.`,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `.`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["ZUORA"]`,
							},
						},
					},
				},
			},
			"stop_reason": schema.StringAttribute{
				Computed:    true,
				Description: `Describes the reason a pipeline has stopped. ` + "`" + `null` + "`" + ` if the pipeline is currently running. If a pipeline is being refreshed, the stop reason will be for the refreshing pipeline. must be one of ["PAUSED", "PARSING_ERRORS", "SCHEMA_CHANGES", "REDSHIFT_RESIZE", "REDSHIFT_MAINTENANCE", "SOURCE_CONNECTION_DOWN", "DESTINATION_CONNECTION_DOWN", "PERMANENTLY_STOPPED", "SOURCE_BROKEN", "QUOTA_REACHED", "SOURCE_INACTIVE", "DESTINATION_INACTIVE", "PIPELINE_MODE_CHANGE"]`,
			},
			"update_schedule": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"daily": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"hour_of_day": schema.Int64Attribute{
								Computed:    true,
								Description: `Hour of day the  pipeline update should be started at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["DAILY"]`,
							},
						},
						Description: `The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.`,
					},
					"hourly": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["HOURLY"]`,
							},
						},
						Description: `The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.`,
					},
					"interval": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"interval_minutes": schema.Int64Attribute{
								Computed:    true,
								Description: `Time to wait before new data is pulled (in minutes).`,
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["INTERVAL"]`,
							},
						},
						Description: `The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.`,
					},
					"monthly": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"day_of_month": schema.Int64Attribute{
								Computed: true,
							},
							"hour_of_day": schema.Int64Attribute{
								Computed:    true,
								Description: `Hour of day the  pipeline update should be started at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["MONTHLY"]`,
							},
						},
						Description: `The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.`,
					},
					"weekly": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"day_of_week": schema.Int64Attribute{
								Computed: true,
							},
							"hour_of_day": schema.Int64Attribute{
								Computed:    true,
								Description: `Hour of day the  pipeline update should be started at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["WEEKLY"]`,
							},
						},
						Description: `The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.`,
					},
				},
				Description: `The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information. When undefined, the pipeline will default to the schedule set on the source connection.`,
			},
		},
	}
}

func (r *PipelineDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.SDK)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected *sdk.SDK, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *PipelineDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data *PipelineDataSourceModel
	var item types.Object

	resp.Diagnostics.Append(req.Config.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	id := data.ID.ValueString()
	request := operations.GetPipelineRequest{
		ID: id,
	}
	res, err := r.client.Pipeline.Get(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.PipelineOutput == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedPipelineOutput(res.PipelineOutput)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
