// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"github.com/etleap/terraform-provider-etleap/internal/sdk"
	"github.com/etleap/terraform-provider-etleap/internal/sdk/pkg/models/operations"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &ModelDataSource{}
var _ datasource.DataSourceWithConfigure = &ModelDataSource{}

func NewModelDataSource() datasource.DataSource {
	return &ModelDataSource{}
}

// ModelDataSource is the data source implementation.
type ModelDataSource struct {
	client *sdk.SDK
}

// ModelDataSourceModel describes the data model.
type ModelDataSourceModel struct {
	CreateDate         types.String         `tfsdk:"create_date"`
	Dependencies       []ModelDependency    `tfsdk:"dependencies"`
	ID                 types.String         `tfsdk:"id"`
	LastUpdateDuration types.Int64          `tfsdk:"last_update_duration"`
	LastUpdateTime     types.String         `tfsdk:"last_update_time"`
	Name               types.String         `tfsdk:"name"`
	Owner              User                 `tfsdk:"owner"`
	Paused             types.Bool           `tfsdk:"paused"`
	QueryAndTriggers   QueryAndTriggers     `tfsdk:"query_and_triggers"`
	Shares             []types.String       `tfsdk:"shares"`
	UpdateSchedule     RefreshScheduleTypes `tfsdk:"update_schedule"`
	Warehouse          WarehouseTypesInput  `tfsdk:"warehouse"`
}

// Metadata returns the data source type name.
func (r *ModelDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_model"
}

// Schema defines the schema for the data source.
func (r *ModelDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Model DataSource",

		Attributes: map[string]schema.Attribute{
			"create_date": schema.StringAttribute{
				Computed:    true,
				Description: `The date and time when then the model was created.`,
			},
			"dependencies": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Computed:    true,
							Description: `The unique identifier of the pipeline or model.`,
						},
						"name": schema.StringAttribute{
							Computed:    true,
							Description: `The name of the pipeline or model.`,
						},
						"type": schema.StringAttribute{
							Computed:    true,
							Description: `must be one of ["PIPELINE", "MODEL"]`,
						},
					},
				},
			},
			"id": schema.StringAttribute{
				Required: true,
			},
			"last_update_duration": schema.Int64Attribute{
				Computed:    true,
				Description: `How long the latest update took to complete, in milliseconds, or the duration of the current update if one is in progress.`,
			},
			"last_update_time": schema.StringAttribute{
				Computed:    true,
				Description: `The date and time of the latest successful update for this model.`,
			},
			"name": schema.StringAttribute{
				Computed: true,
			},
			"owner": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"email_address": schema.StringAttribute{
						Computed: true,
					},
					"first_name": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"last_name": schema.StringAttribute{
						Computed: true,
					},
				},
			},
			"paused": schema.BoolAttribute{
				Computed: true,
			},
			"query_and_triggers": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"query": schema.StringAttribute{
						Computed: true,
						MarkdownDescription: `The SQL query used to build this model. To specify dependencies on pipelines or other models, replace the schema and table name of the dependency with the id of the dependency enclosed in ` + "`" + `{{"{{"}}` + "`" + ` and ` + "`" + `{{"}}"}}` + "`" + `. The dependency must load data into the same Etleap connection as the one given in ` + "`" + `warehouse.connectionId` + "`" + ` for this model.` + "\n" +
							`` + "\n" +
							`**For Example**` + "\n" +
							`Say there is a pipeline with the id ` + "`" + `abcd1234` + "`" + ` which loads data to the table "schema"."my_table". To create a model in Etleap that has a dependency on this pipeline, the following query:` + "\n" +
							`` + "\n" +
							`` + "```" + `sql` + "\n" +
							`SELECT col1, col2 FROM "schema"."my_table";` + "\n" +
							`` + "```" + `` + "\n" +
							`` + "\n" +
							`becomes:` + "\n" +
							`` + "```" + `sql` + "\n" +
							`SELECT col1, col2 FROM {{"{{"}}abcd1234{{"}}"}};` + "\n" +
							`` + "```" + `` + "\n" +
							`` + "\n" +
							`[See the Model documentation](https://docs.etleap.com/docs/documentation/ZG9jOjI0MzU2NDY3-introduction-to-models#model-dependencies) for more information on Model dependencies.`,
					},
					"triggers": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `A list of model dependency ids. An update will be automatically triggered in this model if any of the dependencies listed here get new data. Any ids given here must be present as dependencies in the ` + "`" + `query` + "`" + `.`,
					},
				},
			},
			"shares": schema.ListAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: `An array of users' emails that the model is shared with.  Once shared, a model cannot be unshared, and future calls to ` + "`" + `PATCH` + "`" + ` can only add to this list.`,
			},
			"update_schedule": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"daily": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"hour_of_day": schema.Int64Attribute{
								Computed:    true,
								Description: `Hour of day this schedule should trigger at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["DAILY"]`,
							},
						},
					},
					"hourly": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["HOURLY"]`,
							},
						},
					},
					"monthly": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"day_of_month": schema.Int64Attribute{
								Computed:    true,
								Description: `Day of the month this schedule should trigger at (in UTC).`,
							},
							"hour_of_day": schema.Int64Attribute{
								Computed:    true,
								Description: `Hour of day this schedule should trigger at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["MONTHLY"]`,
							},
						},
					},
					"never": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["NEVER"]`,
							},
						},
					},
					"weekly": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"day_of_week": schema.Int64Attribute{
								Computed:    true,
								Description: `The day of the week this schedule should trigger at (in UTC).`,
							},
							"hour_of_day": schema.Int64Attribute{
								Computed:    true,
								Description: `Hour of day this schedule should trigger at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["WEEKLY"]`,
							},
						},
					},
				},
				Description: `How often this model should update. Etleap will periodically update the model table in your warehouse according to this schedule. See [the Model Updates documentation](https://docs.etleap.com/docs/documentation/ZG9jOjI0MzU2NDY3-introduction-to-models#model-updates) for more information.`,
			},
			"warehouse": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"redshift": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
							},
							"distribution_style": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"one": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["ALL", "AUTO", "EVEN"]`,
									},
									"distribution_style_key": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"column": schema.StringAttribute{
												Computed: true,
											},
											"type": schema.StringAttribute{
												Computed:    true,
												Description: `must be one of ["KEY"]`,
											},
										},
									},
								},
								Description: `Can either be one the strings ` + "`" + `ALL` + "`" + `, ` + "`" + `AUTO` + "`" + ` or ` + "`" + `EVEN` + "`" + `, or an object for ` + "`" + `KEY` + "`" + ` distribution that specifies a column.`,
							},
							"materialized_view": schema.BoolAttribute{
								Computed: true,
							},
							"pending_renamed_table": schema.StringAttribute{
								Computed:    true,
								Description: `Only set when a table rename was triggered but is not complete yet.`,
							},
							"schema": schema.StringAttribute{
								Computed: true,
							},
							"sort_columns": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `The sort columns to use.`,
							},
							"table": schema.StringAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["REDSHIFT"]`,
							},
							"wait_for_update_preparation": schema.BoolAttribute{
								Computed: true,
							},
						},
					},
					"snowflake": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
							},
							"materialized_view": schema.BoolAttribute{
								Computed: true,
							},
							"pending_renamed_table": schema.StringAttribute{
								Computed:    true,
								Description: `Only set when a table rename was triggered but is not complete yet.`,
							},
							"schema": schema.StringAttribute{
								Computed: true,
							},
							"table": schema.StringAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["SNOWFLAKE"]`,
							},
							"wait_for_update_preparation": schema.BoolAttribute{
								Computed: true,
							},
						},
					},
				},
			},
		},
	}
}

func (r *ModelDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.SDK)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected *sdk.SDK, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *ModelDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data *ModelDataSourceModel
	var item types.Object

	resp.Diagnostics.Append(req.Config.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	id := data.ID.ValueString()
	request := operations.GetModelRequest{
		ID: id,
	}
	res, err := r.client.Model.Get(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.ModelOutput == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedModelOutput(res.ModelOutput)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
