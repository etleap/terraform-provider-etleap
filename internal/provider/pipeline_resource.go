// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	speakeasy_boolplanmodifier "github.com/etleap/terraform-provider-etleap/internal/planmodifiers/boolplanmodifier"
	speakeasy_int64planmodifier "github.com/etleap/terraform-provider-etleap/internal/planmodifiers/int64planmodifier"
	speakeasy_listplanmodifier "github.com/etleap/terraform-provider-etleap/internal/planmodifiers/listplanmodifier"
	speakeasy_numberplanmodifier "github.com/etleap/terraform-provider-etleap/internal/planmodifiers/numberplanmodifier"
	speakeasy_objectplanmodifier "github.com/etleap/terraform-provider-etleap/internal/planmodifiers/objectplanmodifier"
	speakeasy_stringplanmodifier "github.com/etleap/terraform-provider-etleap/internal/planmodifiers/stringplanmodifier"
	"github.com/etleap/terraform-provider-etleap/internal/sdk"
	"github.com/etleap/terraform-provider-etleap/internal/sdk/pkg/models/operations"
	"github.com/etleap/terraform-provider-etleap/internal/validators"
	speakeasy_listvalidators "github.com/etleap/terraform-provider-etleap/internal/validators/listvalidators"
	speakeasy_numbervalidators "github.com/etleap/terraform-provider-etleap/internal/validators/numbervalidators"
	speakeasy_stringvalidators "github.com/etleap/terraform-provider-etleap/internal/validators/stringvalidators"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/mapplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &PipelineResource{}
var _ resource.ResourceWithImportState = &PipelineResource{}

func NewPipelineResource() resource.Resource {
	return &PipelineResource{}
}

// PipelineResource defines the resource implementation.
type PipelineResource struct {
	client *sdk.SDK
}

// PipelineResourceModel describes the resource data model.
type PipelineResourceModel struct {
	CreateDate               types.String                         `tfsdk:"create_date"`
	DeletionOfExportProducts types.Bool                           `tfsdk:"deletion_of_export_products"`
	Destination              DestinationTypes                     `tfsdk:"destination"`
	Destinations             []DestinationInfoAndPipelineVersions `tfsdk:"destinations"`
	ID                       types.String                         `tfsdk:"id"`
	LastRefreshFinishDate    types.String                         `tfsdk:"last_refresh_finish_date"`
	LastRefreshStartDate     types.String                         `tfsdk:"last_refresh_start_date"`
	Latency                  types.Int64                          `tfsdk:"latency"`
	LatestScriptVersion      types.Int64                          `tfsdk:"latest_script_version"`
	Name                     types.String                         `tfsdk:"name"`
	Owner                    User                                 `tfsdk:"owner"`
	ParsingErrorSettings     *ParsingErrorSettings                `tfsdk:"parsing_error_settings"`
	Paused                   types.Bool                           `tfsdk:"paused"`
	PipelineMode             types.String                         `tfsdk:"pipeline_mode"`
	RefreshSchedule          RefreshScheduleTypes                 `tfsdk:"refresh_schedule"`
	Script                   *ScriptOrLegacyScriptInput           `tfsdk:"script"`
	Shares                   []types.String                       `tfsdk:"shares"`
	Source                   SourceTypes                          `tfsdk:"source"`
	StopReason               types.String                         `tfsdk:"stop_reason"`
	UpdateSchedule           *UpdateScheduleTypes                 `tfsdk:"update_schedule"`
}

func (r *PipelineResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_pipeline"
}

func (r *PipelineResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Pipeline Resource",

		Attributes: map[string]schema.Attribute{
			"create_date": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `The date and time when then the pipeline was created.`,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
			"deletion_of_export_products": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Default:     booldefault.StaticBool(false),
				Description: `Specifies whether any remaining export products in the destination created by this pipeline should be deleted. For REDSHIFT and SNOWFLAKE destinations this means tables, and for S3 DATA LAKE destinations this means data output to S3 as well as any tables created in Glue. Defaults to ` + "`" + `false` + "`" + `. Default: false`,
			},
			"destination": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Required: true,
				Attributes: map[string]schema.Attribute{
					"delta_lake": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"automatic_schema_changes": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `. Requires replacement if changed. ; Default: true`,
							},
							"connection_id": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `The universally unique identifier of the destination connection. Requires replacement if changed. `,
							},
							"last_updated_column": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the destination. Requires replacement if changed. `,
							},
							"pre10_dot2_runtime_support": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								Default:  booldefault.StaticBool(false),
								MarkdownDescription: `This setting disables column mapping on the tables created by this pipeline.` + "\n" +
									`` + "\n" +
									`When enabled, this pipeline will create Delta Lake tables that can be read by Databricks clusters with runtime versions before 10.2.` + "\n" +
									`` + "\n" +
									`However, without column mapping, native schema changes are not supported and will cause the table's underlying Parquet files to be rewritten, which can be slow. Schema changes will also not preserve column constraints such as ` + "`" + `NOT NULL` + "`" + ` on the destination tables.` + "\n" +
									`Requires replacement if changed. ; Default: false`,
							},
							"primary_key": schema.ListAttribute{
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"retain_history": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `If the destination table should retain the history of the source. More information here: https://docs.etleap.com/docs/documentation/56a1503dc499e-update-with-history-retention-mode. Defaults to ` + "`" + `false` + "`" + `. Requires replacement if changed. ; Default: false`,
							},
							"schema": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `The schema in the destination that the tables will be created in. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `Requires replacement if changed. ; must be one of ["DELTA_LAKE"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"DELTA_LAKE",
									),
								},
							},
							"wait_for_quality_check": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `. Requires replacement if changed. ; Default: false`,
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"iceberg": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"automatic_schema_changes": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `. Requires replacement if changed. ; Default: true`,
							},
							"connection_id": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `The universally unique identifier of the destination connection. Requires replacement if changed. `,
							},
							"primary_key": schema.ListAttribute{
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"schema": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Description: `The schema in the destination that the tables will be created in. If this is not specified or set to ` + "`" + `null` + "`" + ` then the schema specified on the connection is used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `Requires replacement if changed. ; must be one of ["ICEBERG"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"ICEBERG",
									),
								},
							},
							"wait_for_quality_check": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `. Requires replacement if changed. ; Default: false`,
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"redshift": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"automatic_schema_changes": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `. Requires replacement if changed. ; Default: true`,
							},
							"compress_columns": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Whether columns should be compressed. Defaults to ` + "`" + `true` + "`" + `. Requires replacement if changed. ; Default: true`,
							},
							"connection_id": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `The universally unique identifier of the destination connection. Requires replacement if changed. `,
							},
							"distribution_style": schema.SingleNestedAttribute{
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"one": schema.StringAttribute{
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
										},
										Optional:    true,
										Description: `Requires replacement if changed. ; must be one of ["ALL", "AUTO", "EVEN"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"ALL",
												"AUTO",
												"EVEN",
											),
										},
									},
									"distribution_style_key": schema.SingleNestedAttribute{
										PlanModifiers: []planmodifier.Object{
											objectplanmodifier.RequiresReplaceIfConfigured(),
										},
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"column": schema.StringAttribute{
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.RequiresReplaceIfConfigured(),
												},
												Required:    true,
												Description: `Requires replacement if changed. `,
											},
											"type": schema.StringAttribute{
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.RequiresReplaceIfConfigured(),
												},
												Required:    true,
												Description: `Requires replacement if changed. ; must be one of ["KEY"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"KEY",
													),
												},
											},
										},
										Description: `Requires replacement if changed. `,
									},
								},
								Description: `Can either be one the strings ` + "`" + `ALL` + "`" + `, ` + "`" + `AUTO` + "`" + ` or ` + "`" + `EVEN` + "`" + `, or an object for ` + "`" + `KEY` + "`" + ` distribution that specifies a column. Requires replacement if changed. `,
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the destination. Requires replacement if changed. `,
							},
							"primary_key": schema.ListAttribute{
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"retain_history": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `If the destination table should retain the history of the source. More information here: https://docs.etleap.com/docs/documentation/56a1503dc499e-update-with-history-retention-mode. Defaults to ` + "`" + `false` + "`" + `. Requires replacement if changed. ; Default: false`,
							},
							"schema": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Description: `The schema in the destination that the tables will be created in. If this is not specified or set to ` + "`" + `null` + "`" + ` then the schema specified on the connection is used. Requires replacement if changed. `,
							},
							"sort_columns": schema.ListAttribute{
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `The sort columns to use. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"table": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `Requires replacement if changed. `,
							},
							"truncate_strings": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Truncate strings to 64K characters, the max allowed by Redshift in a single column. Defaults to ` + "`" + `false` + "`" + `. Requires replacement if changed. ; Default: false`,
							},
							"type": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `Requires replacement if changed. ; must be one of ["REDSHIFT"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"REDSHIFT",
									),
								},
							},
							"wait_for_quality_check": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `. Requires replacement if changed. ; Default: false`,
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"s3_data_lake": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"automatic_schema_changes": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `. Requires replacement if changed. ; Default: true`,
							},
							"connection_id": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `The universally unique identifier of the destination connection. Requires replacement if changed. `,
							},
							"generate_snapshots": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Defaults to 'false'. Requires replacement if changed. ; Default: false`,
							},
							"output_format": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     stringdefault.StaticString("PARQUET"),
								Description: `Format for output files. Defaults to ` + "`" + `PARQUET` + "`" + `. For Glue-enabled destinations, only ` + "`" + `PARQUET` + "`" + ` is a valid format. Requires replacement if changed. ; must be one of ["PARQUET", "CSV"]; Default: "PARQUET"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"PARQUET",
										"CSV",
									),
								},
							},
							"path_prefix": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `The S3 path prefix to use for this pipeline. The data key in the destination bucket starts with ` + "`" + `{connection.pathPrefix}/{pathPrefix}/v{version.pipeline}/` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key": schema.ListAttribute{
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"type": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `Requires replacement if changed. ; must be one of ["S3_DATA_LAKE"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"S3_DATA_LAKE",
									),
								},
							},
							"wait_for_quality_check": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `. Requires replacement if changed. ; Default: false`,
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"snowflake": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"automatic_schema_changes": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `. Requires replacement if changed. ; Default: true`,
							},
							"clustering_keys": schema.ListAttribute{
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Keys to cluster the table on. If unspecified, the table will use "automatic clustering". Requires replacement if changed. `,
							},
							"connection_id": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `The universally unique identifier of the destination connection. Requires replacement if changed. `,
							},
							"last_updated_column": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the destination. Requires replacement if changed. `,
							},
							"primary_key": schema.ListAttribute{
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"retain_history": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `If the destination table should retain the history of the source. More information here: https://docs.etleap.com/docs/documentation/56a1503dc499e-update-with-history-retention-mode. Defaults to ` + "`" + `false` + "`" + `. Requires replacement if changed. ; Default: false`,
							},
							"schema": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Description: `The schema in the destination that the tables will be created in. If this is not specified or set to ` + "`" + `null` + "`" + ` then the schema specified on the connection is used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `Requires replacement if changed. ; must be one of ["SNOWFLAKE"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"SNOWFLAKE",
									),
								},
							},
							"wait_for_quality_check": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `. Requires replacement if changed. ; Default: false`,
							},
						},
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Requires replacement if changed. `,
				Validators: []validator.Object{
					validators.ExactlyOneChild(),
				},
			},
			"destinations": schema.ListNestedAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.List{
					speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"current_version": schema.Int64Attribute{
							Computed: true,
							PlanModifiers: []planmodifier.Int64{
								speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
							},
							Description: `The version of the pipeline that is currently writing to the output table.`,
						},
						"destination": schema.SingleNestedAttribute{
							Computed: true,
							PlanModifiers: []planmodifier.Object{
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"delta_lake": schema.SingleNestedAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"automatic_schema_changes": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `.`,
										},
										"connection_id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The universally unique identifier of the destination connection.`,
										},
										"last_updated_column": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Name of a column that indicates the time the record was updated at the destination.`,
										},
										"pre10_dot2_runtime_support": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											MarkdownDescription: `This setting disables column mapping on the tables created by this pipeline.` + "\n" +
												`` + "\n" +
												`When enabled, this pipeline will create Delta Lake tables that can be read by Databricks clusters with runtime versions before 10.2.` + "\n" +
												`` + "\n" +
												`However, without column mapping, native schema changes are not supported and will cause the table's underlying Parquet files to be rewritten, which can be slow. Schema changes will also not preserve column constraints such as ` + "`" + `NOT NULL` + "`" + ` on the destination tables.`,
										},
										"primary_key": schema.ListAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.List{
												speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
											},
											ElementType: types.StringType,
											Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier.`,
											Validators: []validator.List{
												listvalidator.SizeAtLeast(1),
											},
										},
										"retain_history": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `If the destination table should retain the history of the source. More information here: https://docs.etleap.com/docs/documentation/56a1503dc499e-update-with-history-retention-mode. Defaults to ` + "`" + `false` + "`" + `.`,
										},
										"schema": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The schema in the destination that the tables will be created in.`,
										},
										"table": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
										},
										"type": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `must be one of ["DELTA_LAKE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"DELTA_LAKE",
												),
											},
										},
										"wait_for_quality_check": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `.`,
										},
									},
								},
								"iceberg": schema.SingleNestedAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"automatic_schema_changes": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `.`,
										},
										"connection_id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The universally unique identifier of the destination connection.`,
										},
										"primary_key": schema.ListAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.List{
												speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
											},
											ElementType: types.StringType,
											Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier.`,
											Validators: []validator.List{
												listvalidator.SizeAtLeast(1),
											},
										},
										"schema": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The schema in the destination that the tables will be created in. If this is not specified or set to ` + "`" + `null` + "`" + ` then the schema specified on the connection is used.`,
										},
										"table": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
										},
										"type": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `must be one of ["ICEBERG"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"ICEBERG",
												),
											},
										},
										"wait_for_quality_check": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `.`,
										},
									},
								},
								"redshift": schema.SingleNestedAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"automatic_schema_changes": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `.`,
										},
										"compress_columns": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `Whether columns should be compressed. Defaults to ` + "`" + `true` + "`" + `.`,
										},
										"connection_id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The universally unique identifier of the destination connection.`,
										},
										"distribution_style": schema.SingleNestedAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Object{
												speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
											},
											Attributes: map[string]schema.Attribute{
												"one": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `must be one of ["ALL", "AUTO", "EVEN"]`,
													Validators: []validator.String{
														stringvalidator.OneOf(
															"ALL",
															"AUTO",
															"EVEN",
														),
													},
												},
												"distribution_style_key": schema.SingleNestedAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.Object{
														speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
													},
													Attributes: map[string]schema.Attribute{
														"column": schema.StringAttribute{
															Computed: true,
															PlanModifiers: []planmodifier.String{
																speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
															},
														},
														"type": schema.StringAttribute{
															Computed: true,
															PlanModifiers: []planmodifier.String{
																speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
															},
															Description: `must be one of ["KEY"]`,
															Validators: []validator.String{
																stringvalidator.OneOf(
																	"KEY",
																),
															},
														},
													},
												},
											},
											Description: `Can either be one the strings ` + "`" + `ALL` + "`" + `, ` + "`" + `AUTO` + "`" + ` or ` + "`" + `EVEN` + "`" + `, or an object for ` + "`" + `KEY` + "`" + ` distribution that specifies a column.`,
											Validators: []validator.Object{
												validators.ExactlyOneChild(),
											},
										},
										"last_updated_column": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Name of a column that indicates the time the record was updated at the destination.`,
										},
										"primary_key": schema.ListAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.List{
												speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
											},
											ElementType: types.StringType,
											Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier.`,
											Validators: []validator.List{
												listvalidator.SizeAtLeast(1),
											},
										},
										"retain_history": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `If the destination table should retain the history of the source. More information here: https://docs.etleap.com/docs/documentation/56a1503dc499e-update-with-history-retention-mode. Defaults to ` + "`" + `false` + "`" + `.`,
										},
										"schema": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The schema in the destination that the tables will be created in. If this is not specified or set to ` + "`" + `null` + "`" + ` then the schema specified on the connection is used.`,
										},
										"sort_columns": schema.ListAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.List{
												speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
											},
											ElementType: types.StringType,
											Description: `The sort columns to use.`,
											Validators: []validator.List{
												listvalidator.SizeAtLeast(1),
											},
										},
										"table": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
										},
										"truncate_strings": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `Truncate strings to 64K characters, the max allowed by Redshift in a single column. Defaults to ` + "`" + `false` + "`" + `.`,
										},
										"type": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `must be one of ["REDSHIFT"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"REDSHIFT",
												),
											},
										},
										"wait_for_quality_check": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `.`,
										},
									},
								},
								"s3_data_lake": schema.SingleNestedAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"automatic_schema_changes": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `.`,
										},
										"connection_id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The universally unique identifier of the destination connection.`,
										},
										"generate_snapshots": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `Defaults to 'false'.`,
										},
										"output_format": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Format for output files. Defaults to ` + "`" + `PARQUET` + "`" + `. For Glue-enabled destinations, only ` + "`" + `PARQUET` + "`" + ` is a valid format. must be one of ["PARQUET", "CSV"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"PARQUET",
													"CSV",
												),
											},
										},
										"path_prefix": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The S3 path prefix to use for this pipeline. The data key in the destination bucket starts with ` + "`" + `{connection.pathPrefix}/{pathPrefix}/v{version.pipeline}/` + "`" + `.`,
										},
										"primary_key": schema.ListAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.List{
												speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
											},
											ElementType: types.StringType,
											Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier.`,
											Validators: []validator.List{
												listvalidator.SizeAtLeast(1),
											},
										},
										"type": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `must be one of ["S3_DATA_LAKE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"S3_DATA_LAKE",
												),
											},
										},
										"wait_for_quality_check": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `.`,
										},
									},
								},
								"snowflake": schema.SingleNestedAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"automatic_schema_changes": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `Whether schema changes detected during transformation should be handled automatically or not. Defaults to ` + "`" + `true` + "`" + `.`,
										},
										"clustering_keys": schema.ListAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.List{
												speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
											},
											ElementType: types.StringType,
											Description: `Keys to cluster the table on. If unspecified, the table will use "automatic clustering".`,
										},
										"connection_id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The universally unique identifier of the destination connection.`,
										},
										"last_updated_column": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Name of a column that indicates the time the record was updated at the destination.`,
										},
										"primary_key": schema.ListAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.List{
												speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
											},
											ElementType: types.StringType,
											Description: `The destination column names that constitute the primary key. <br> If the pipline has a sharded source include a column that specifies the shard identifier.`,
											Validators: []validator.List{
												listvalidator.SizeAtLeast(1),
											},
										},
										"retain_history": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `If the destination table should retain the history of the source. More information here: https://docs.etleap.com/docs/documentation/56a1503dc499e-update-with-history-retention-mode. Defaults to ` + "`" + `false` + "`" + `.`,
										},
										"schema": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The schema in the destination that the tables will be created in. If this is not specified or set to ` + "`" + `null` + "`" + ` then the schema specified on the connection is used.`,
										},
										"table": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
										},
										"type": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `must be one of ["SNOWFLAKE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"SNOWFLAKE",
												),
											},
										},
										"wait_for_quality_check": schema.BoolAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.Bool{
												speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
											},
											Description: `If set to ` + "`" + `true` + "`" + `, a ` + "`" + `Transformation Complete` + "`" + ` event is published once a transformation completes, and the pipeline waits for a ` + "`" + `Quality Check Complete` + "`" + ` event before loading to the destination. Defaults to ` + "`" + `false` + "`" + `.`,
										},
									},
								},
							},
							Validators: []validator.Object{
								validators.ExactlyOneChild(),
							},
						},
						"parsing_errors": schema.SingleNestedAttribute{
							Computed: true,
							PlanModifiers: []planmodifier.Object{
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"operation_errors_by_operation": schema.ListNestedAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.List{
										speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
									},
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"operation_description": schema.StringAttribute{
												Computed: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"operation_index": schema.Int64Attribute{
												Computed: true,
												PlanModifiers: []planmodifier.Int64{
													speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
												},
												Description: `Index of step in the script of this pipeline that caused this error.`,
											},
											"row_count": schema.Int64Attribute{
												Computed: true,
												PlanModifiers: []planmodifier.Int64{
													speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
												},
											},
										},
									},
								},
								"parsing_errors_per_day": schema.ListNestedAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.List{
										speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
									},
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"day": schema.StringAttribute{
												Computed: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
												Description: `Format of the timestamp: 'yyyy-MM-dd'`,
												Validators: []validator.String{
													validators.IsValidDate(),
												},
											},
											"error_type": schema.StringAttribute{
												Computed: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
												Description: `must be one of ["TYPE", "OPERATION"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"TYPE",
														"OPERATION",
													),
												},
											},
											"row_count": schema.Int64Attribute{
												Computed: true,
												PlanModifiers: []planmodifier.Int64{
													speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
												},
											},
										},
									},
								},
								"type_errors_by_column": schema.ListNestedAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.List{
										speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
									},
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"column_name": schema.StringAttribute{
												Computed: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"row_count": schema.Int64Attribute{
												Computed: true,
												PlanModifiers: []planmodifier.Int64{
													speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
												},
											},
											"type": schema.StringAttribute{
												Computed: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
										},
									},
								},
							},
							Description: `Parsing errors that occur during the transformation of the pipeline. If a pipeline is being refreshed, these errors will be for the refreshing pipeline.`,
						},
						"refresh_version": schema.Int64Attribute{
							Computed: true,
							PlanModifiers: []planmodifier.Int64{
								speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
							},
							Description: `The version of the pipeline that is currently writing to the temporary refresh table. Only specified if there's currently a refresh in progress.`,
						},
						"retention_data": schema.SingleNestedAttribute{
							Computed: true,
							PlanModifiers: []planmodifier.Object{
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"retention_by_day": schema.SingleNestedAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"rows_currently_in_warehouse": schema.ListNestedAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.List{
												speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
											},
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"date": schema.StringAttribute{
														Computed: true,
														PlanModifiers: []planmodifier.String{
															speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
														},
														Description: `Format of the timestamp: 'yyyy-MM-dd'`,
														Validators: []validator.String{
															validators.IsValidDate(),
														},
													},
													"row_count": schema.Int64Attribute{
														Computed: true,
														PlanModifiers: []planmodifier.Int64{
															speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
														},
													},
												},
											},
										},
										"rows_removed_from_warehouse": schema.ListNestedAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.List{
												speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
											},
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"date": schema.StringAttribute{
														Computed: true,
														PlanModifiers: []planmodifier.String{
															speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
														},
														Description: `Format of the timestamp: 'yyyy-MM-dd'`,
														Validators: []validator.String{
															validators.IsValidDate(),
														},
													},
													"row_count": schema.Int64Attribute{
														Computed: true,
														PlanModifiers: []planmodifier.Int64{
															speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
														},
													},
												},
											},
										},
									},
								},
								"retention_policy": schema.SingleNestedAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"column": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Name of the column that is used to calculate the interval. Must be a ` + "`" + `date` + "`" + ` or a ` + "`" + `datetime` + "`" + ` column.`,
										},
										"period": schema.Int64Attribute{
											Computed: true,
											PlanModifiers: []planmodifier.Int64{
												speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
											},
											Description: `Number of days before a row gets removed.`,
										},
									},
									Description: `Policy for the automatic deletion of rows in the destination.`,
								},
							},
							Description: `Etleap can remove old rows from your destination. This is a summary of the data retention. If a pipeline is being refreshed, this will be the summary for the refreshing pipeline.`,
						},
						"schema_change_activity": schema.ListNestedAttribute{
							Computed: true,
							PlanModifiers: []planmodifier.List{
								speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
							},
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"date_time": schema.StringAttribute{
										Computed: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The date and time of the schema change. ` + "`" + `null` + "`" + ` if schema change has not yet been applied.`,
										Validators: []validator.String{
											validators.IsRFC3339(),
										},
									},
									"schema_change_description": schema.StringAttribute{
										Computed: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
								},
							},
							Description: `Array of schema change objects. If a pipeline is being refreshed, the schema change activities will be for the refreshing pipeline.`,
						},
					},
				},
				Description: `A pipeline may have multiple destinations if it is in the process of being migrated from one to another.`,
				Validators: []validator.List{
					listvalidator.SizeAtLeast(1),
				},
			},
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `The unique identifier of the pipeline.`,
			},
			"last_refresh_finish_date": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `The date and time when the last refresh finished. ` + "`" + `null` + "`" + ` if the pipeline was never refreshed.`,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
			"last_refresh_start_date": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `The date and time when the last refresh was started. ` + "`" + `null` + "`" + ` if the pipeline was never refreshed.`,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
			"latency": schema.Int64Attribute{
				Computed: true,
				PlanModifiers: []planmodifier.Int64{
					speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
				},
				Description: `The end-to-end latency in seconds for this pipeline. Not ` + "`" + `null` + "`" + ` if the pipeline is running (not paused or stopped) and if the initial backfill has finished. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjIyMTU3NTQ3-latency#end-to-end-latency">the documentation</a> for more details.`,
			},
			"latest_script_version": schema.Int64Attribute{
				Computed: true,
				PlanModifiers: []planmodifier.Int64{
					speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
				},
				Description: `Valid script versions are whole numbers and range from 1 to this number.`,
			},
			"name": schema.StringAttribute{
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Required: true,
			},
			"owner": schema.SingleNestedAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.Object{
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"email_address": schema.StringAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
					"first_name": schema.StringAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
					"last_name": schema.StringAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
				},
			},
			"parsing_error_settings": schema.SingleNestedAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.Object{
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"action": schema.StringAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Optional:    true,
						Description: `Whether Etleap should STOP the pipeline or NOTIFY once the ` + "`" + `threshold` + "`" + ` is reached. Not Null; must be one of ["STOP", "NOTIFY"]`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"STOP",
								"NOTIFY",
							),
						},
					},
					"threshold": schema.NumberAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Number{
							speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
						},
						Optional:    true,
						Description: `The parsing error threshold, in percentage points, for the ` + "`" + `action` + "`" + ` to be triggered. Not Null`,
						Validators: []validator.Number{
							speakeasy_numbervalidators.NotNull(),
						},
					},
				},
			},
			"paused": schema.BoolAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.Bool{
					speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
				},
				Optional:    true,
				Default:     booldefault.StaticBool(false),
				Description: `If the pipeline is paused. Defaults to ` + "`" + `false` + "`" + `. Default: false`,
			},
			"pipeline_mode": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `The pipeline mode refers to how the pipeline fetches data changes from the source and how those changes are applied to the destination table. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjIyMjE3ODA2-introduction">the documentation</a> for more details. must be one of ["APPEND", "REPLACE", "UPDATE", "QUERY"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"APPEND",
						"REPLACE",
						"UPDATE",
						"QUERY",
					),
				},
			},
			"refresh_schedule": schema.SingleNestedAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.Object{
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"daily": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"hour_of_day": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Description: `Hour of day this schedule should trigger at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `must be one of ["DAILY"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"DAILY",
									),
								},
							},
						},
					},
					"hourly": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"mode": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `must be one of ["HOURLY"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"HOURLY",
									),
								},
							},
						},
					},
					"monthly": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"day_of_month": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Description: `Day of the month this schedule should trigger at (in UTC).`,
							},
							"hour_of_day": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Description: `Hour of day this schedule should trigger at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `must be one of ["MONTHLY"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"MONTHLY",
									),
								},
							},
						},
					},
					"never": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"mode": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `must be one of ["NEVER"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"NEVER",
									),
								},
							},
						},
					},
					"weekly": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"day_of_week": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Description: `The day of the week this schedule should trigger at (in UTC).`,
							},
							"hour_of_day": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Description: `Hour of day this schedule should trigger at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `must be one of ["WEEKLY"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"WEEKLY",
									),
								},
							},
						},
					},
				},
				MarkdownDescription: `A pipeline refresh processes all data in your source from the beginning to re-establish consistency with your destination. The pipeline refresh schedule defines when Etleap should automatically refresh the pipeline. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.` + "\n" +
					`` + "\n" +
					`Setting this to ` + "`" + `null` + "`" + ` is equivalent to setting the Refresh Schedule to ` + "`" + `NEVER` + "`" + `. `,
				Validators: []validator.Object{
					validators.ExactlyOneChild(),
				},
			},
			"script": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"legacy_script": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"legacy_script": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required:    true,
								Description: `The serialization of a script. Not meant to be human-readable. Requires replacement if changed. `,
							},
						},
						Description: `To be used only for copying a script exactly. Requires replacement if changed. `,
					},
					"script": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"charset": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional:    true,
								Description: `Defaults to UTF-8. Requires replacement if changed. `,
							},
							"inferred_column_types": schema.MapNestedAttribute{
								PlanModifiers: []planmodifier.Map{
									mapplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"type_1": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional:    true,
											Description: `Note: JSON_OBJECT is deprecated and is a synonym of JSON. Requires replacement if changed. ; must be one of ["AUTO", "BIGINT", "BOOLEAN", "DATE", "DATETIME", "DOUBLE", "STRING", "JSON_OBJECT", "JSON"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"AUTO",
													"BIGINT",
													"BOOLEAN",
													"DATE",
													"DATETIME",
													"DOUBLE",
													"STRING",
													"JSON_OBJECT",
													"JSON",
												),
											},
										},
										"type_decimal": schema.SingleNestedAttribute{
											PlanModifiers: []planmodifier.Object{
												objectplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"precision": schema.Int64Attribute{
													PlanModifiers: []planmodifier.Int64{
														int64planmodifier.RequiresReplaceIfConfigured(),
													},
													Required:    true,
													Description: `Requires replacement if changed. `,
												},
												"scale": schema.Int64Attribute{
													PlanModifiers: []planmodifier.Int64{
														int64planmodifier.RequiresReplaceIfConfigured(),
													},
													Required:    true,
													Description: `Requires replacement if changed. `,
												},
												"type": schema.StringAttribute{
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.RequiresReplaceIfConfigured(),
													},
													Required:    true,
													Description: `Requires replacement if changed. ; must be one of ["DECIMAL"]`,
													Validators: []validator.String{
														stringvalidator.OneOf(
															"DECIMAL",
														),
													},
												},
											},
											Description: `Requires replacement if changed. `,
										},
										"type_string_with_max_length": schema.SingleNestedAttribute{
											PlanModifiers: []planmodifier.Object{
												objectplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"length": schema.Int64Attribute{
													PlanModifiers: []planmodifier.Int64{
														int64planmodifier.RequiresReplaceIfConfigured(),
													},
													Required:    true,
													Description: `Maximum string length in bytes. Requires replacement if changed. `,
												},
												"type": schema.StringAttribute{
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.RequiresReplaceIfConfigured(),
													},
													Required:    true,
													Description: `Requires replacement if changed. ; must be one of ["STRING"]`,
													Validators: []validator.String{
														stringvalidator.OneOf(
															"STRING",
														),
													},
												},
											},
											Description: `Requires replacement if changed. `,
										},
									},
									Validators: []validator.Object{
										validators.ExactlyOneChild(),
									},
								},
								Description: `Maps output column names to types inferred from data. Requires replacement if changed. `,
							},
							"transforms": schema.ListNestedAttribute{
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
								},
								Required: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"transform_add_file_path": schema.SingleNestedAttribute{
											PlanModifiers: []planmodifier.Object{
												objectplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"type": schema.StringAttribute{
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.RequiresReplaceIfConfigured(),
													},
													Required:    true,
													Description: `Requires replacement if changed. ; must be one of ["ADD_FILE_PATH"]`,
													Validators: []validator.String{
														stringvalidator.OneOf(
															"ADD_FILE_PATH",
														),
													},
												},
											},
											Description: `Add the file path. Creates a column containing the path where each row was extracted from. <br/>The new column is called ` + "`" + `file_path` + "`" + `. Requires replacement if changed. `,
										},
										"transform_extract_json_fields": schema.SingleNestedAttribute{
											PlanModifiers: []planmodifier.Object{
												objectplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"column": schema.StringAttribute{
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.RequiresReplaceIfConfigured(),
													},
													Required:    true,
													Description: `The input column containing the JSON to flatten. Requires replacement if changed. `,
												},
												"discover_new_keys": schema.BoolAttribute{
													PlanModifiers: []planmodifier.Bool{
														boolplanmodifier.RequiresReplaceIfConfigured(),
													},
													Required:    true,
													Description: `If enabled, Etleap will discover new JSON keys at runtime and add these to the script. See the documentation for more details: https://support.etleap.com/hc/en-us/articles/360006296714-Auto-Discovery-of-JSON-Keys. Requires replacement if changed. `,
												},
												"keys": schema.ListNestedAttribute{
													PlanModifiers: []planmodifier.List{
														listplanmodifier.RequiresReplaceIfConfigured(),
													},
													Required: true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"name": schema.StringAttribute{
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.RequiresReplaceIfConfigured(),
																},
																Required:    true,
																Description: `Requires replacement if changed. `,
															},
															"type": schema.SingleNestedAttribute{
																PlanModifiers: []planmodifier.Object{
																	objectplanmodifier.RequiresReplaceIfConfigured(),
																},
																Required: true,
																Attributes: map[string]schema.Attribute{
																	"one": schema.StringAttribute{
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.RequiresReplaceIfConfigured(),
																		},
																		Optional:    true,
																		Description: `Note: JSON_OBJECT is deprecated and is a synonym of JSON. Requires replacement if changed. ; must be one of ["AUTO", "BIGINT", "BOOLEAN", "DATE", "DATETIME", "DOUBLE", "STRING", "JSON_OBJECT", "JSON"]`,
																		Validators: []validator.String{
																			stringvalidator.OneOf(
																				"AUTO",
																				"BIGINT",
																				"BOOLEAN",
																				"DATE",
																				"DATETIME",
																				"DOUBLE",
																				"STRING",
																				"JSON_OBJECT",
																				"JSON",
																			),
																		},
																	},
																	"type_decimal": schema.SingleNestedAttribute{
																		PlanModifiers: []planmodifier.Object{
																			objectplanmodifier.RequiresReplaceIfConfigured(),
																		},
																		Optional: true,
																		Attributes: map[string]schema.Attribute{
																			"precision": schema.Int64Attribute{
																				PlanModifiers: []planmodifier.Int64{
																					int64planmodifier.RequiresReplaceIfConfigured(),
																				},
																				Required:    true,
																				Description: `Requires replacement if changed. `,
																			},
																			"scale": schema.Int64Attribute{
																				PlanModifiers: []planmodifier.Int64{
																					int64planmodifier.RequiresReplaceIfConfigured(),
																				},
																				Required:    true,
																				Description: `Requires replacement if changed. `,
																			},
																			"type": schema.StringAttribute{
																				PlanModifiers: []planmodifier.String{
																					stringplanmodifier.RequiresReplaceIfConfigured(),
																				},
																				Required:    true,
																				Description: `Requires replacement if changed. ; must be one of ["DECIMAL"]`,
																				Validators: []validator.String{
																					stringvalidator.OneOf(
																						"DECIMAL",
																					),
																				},
																			},
																		},
																		Description: `Requires replacement if changed. `,
																	},
																	"type_string_with_max_length": schema.SingleNestedAttribute{
																		PlanModifiers: []planmodifier.Object{
																			objectplanmodifier.RequiresReplaceIfConfigured(),
																		},
																		Optional: true,
																		Attributes: map[string]schema.Attribute{
																			"length": schema.Int64Attribute{
																				PlanModifiers: []planmodifier.Int64{
																					int64planmodifier.RequiresReplaceIfConfigured(),
																				},
																				Required:    true,
																				Description: `Maximum string length in bytes. Requires replacement if changed. `,
																			},
																			"type": schema.StringAttribute{
																				PlanModifiers: []planmodifier.String{
																					stringplanmodifier.RequiresReplaceIfConfigured(),
																				},
																				Required:    true,
																				Description: `Requires replacement if changed. ; must be one of ["STRING"]`,
																				Validators: []validator.String{
																					stringvalidator.OneOf(
																						"STRING",
																					),
																				},
																			},
																		},
																		Description: `Requires replacement if changed. `,
																	},
																},
																Description: `Requires replacement if changed. `,
																Validators: []validator.Object{
																	validators.ExactlyOneChild(),
																},
															},
														},
													},
													Description: `Maps keys to extract from the JSON object to their types. Requires replacement if changed. `,
												},
												"prefix": schema.StringAttribute{
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.RequiresReplaceIfConfigured(),
													},
													Optional:    true,
													Description: `If specified, Etleap will prepend this value to column names produced by this transform. This can be useful to add context for column names and avoid collisions between column names of keys extracted from different objects. Requires replacement if changed. `,
												},
												"type": schema.StringAttribute{
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.RequiresReplaceIfConfigured(),
													},
													Required:    true,
													Description: `Requires replacement if changed. ; must be one of ["FLATTEN_JSON_OBJECT"]`,
													Validators: []validator.String{
														stringvalidator.OneOf(
															"FLATTEN_JSON_OBJECT",
														),
													},
												},
											},
											Description: `Flattens a JSON object into columns. Requires replacement if changed. `,
										},
										"transform_parquet_to_rows": schema.SingleNestedAttribute{
											PlanModifiers: []planmodifier.Object{
												objectplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"type": schema.StringAttribute{
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.RequiresReplaceIfConfigured(),
													},
													Required:    true,
													Description: `Requires replacement if changed. ; must be one of ["PARQUET_TO_ROWS"]`,
													Validators: []validator.String{
														stringvalidator.OneOf(
															"PARQUET_TO_ROWS",
														),
													},
												},
											},
											Description: `Parses Parquet files to rows of JSON objects. Requires replacement if changed. `,
										},
										"transform_parse_by_regex": schema.SingleNestedAttribute{
											PlanModifiers: []planmodifier.Object{
												objectplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"column": schema.StringAttribute{
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.RequiresReplaceIfConfigured(),
													},
													Required:    true,
													Description: `The input column that should be parsed by regex. Requires replacement if changed. `,
												},
												"regex": schema.StringAttribute{
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.RequiresReplaceIfConfigured(),
													},
													Required:    true,
													Description: `The regular expression. Requires replacement if changed. `,
												},
												"type": schema.StringAttribute{
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.RequiresReplaceIfConfigured(),
													},
													Required:    true,
													Description: `Requires replacement if changed. ; must be one of ["PARSE_BY_REGEX"]`,
													Validators: []validator.String{
														stringvalidator.OneOf(
															"PARSE_BY_REGEX",
														),
													},
												},
											},
											Description: `Parse a column using a regular expression. Use regular expression capture groups to extract matched content into new columns. <br/> The new parsed columns are called ` + "`" + `parse` + "`" + `, ` + "`" + `parse1` + "`" + ` etc. Requires replacement if changed. `,
										},
										"transform_rename_columns": schema.SingleNestedAttribute{
											PlanModifiers: []planmodifier.Object{
												objectplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"columns": schema.ListNestedAttribute{
													PlanModifiers: []planmodifier.List{
														listplanmodifier.RequiresReplaceIfConfigured(),
													},
													Required: true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"column": schema.StringAttribute{
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.RequiresReplaceIfConfigured(),
																},
																Required:    true,
																Description: `Old column name. Requires replacement if changed. `,
															},
															"name": schema.StringAttribute{
																PlanModifiers: []planmodifier.String{
																	stringplanmodifier.RequiresReplaceIfConfigured(),
																},
																Required:    true,
																Description: `New column name. Name must be unique in column list. Requires replacement if changed. `,
															},
														},
													},
													Description: `Maps old column names to the new column names. Requires replacement if changed. `,
													Validators: []validator.List{
														listvalidator.UniqueValues(),
													},
												},
												"type": schema.StringAttribute{
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.RequiresReplaceIfConfigured(),
													},
													Required:    true,
													Description: `Requires replacement if changed. ; must be one of ["RENAME_COLUMNS"]`,
													Validators: []validator.String{
														stringvalidator.OneOf(
															"RENAME_COLUMNS",
														),
													},
												},
											},
											Description: `Rename exisiting columns. Requires replacement if changed. `,
										},
									},
									Validators: []validator.Object{
										validators.ExactlyOneChild(),
									},
								},
								Description: `An array consisting of a single "To Rows" transform followed by any number of other transforms. Requires replacement if changed. `,
							},
						},
						Description: `Specifies a script based on an array of transforms. Not all transforms available in the Wrangler are supported yet for this script format. Requires replacement if changed. `,
					},
				},
				Description: `Whenever a script is required, we accept and/or return two types of scripts: a Script or Legacy Script. We return a Script object if all transforms specified in that script are supported by this API. Otherwise it will return a Legacy Script. Either Script or Legacy Script can be used when adding a script to a pipeline. Requires replacement if changed. `,
				Validators: []validator.Object{
					validators.ExactlyOneChild(),
				},
			},
			"shares": schema.ListAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.List{
					speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
				},
				Optional:    true,
				ElementType: types.StringType,
				MarkdownDescription: `An array of user email's to share the pipeline with.` + "\n" +
					`` + "\n" +
					`Once shared, a pipeline cannot be unshared. Future call to ` + "`" + `PATCH` + "`" + ` on a pipeline can only add to this list.`,
			},
			"source": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Required: true,
				Attributes: map[string]schema.Attribute{
					"active_campaign": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The ActiveCampaign resource. Example: Contacts, Custom Fields and Custom Values. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["ACTIVE_CAMPAIGN"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"ACTIVE_CAMPAIGN",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"bigquery": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"dataset": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of dataset in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["BIGQUERY"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"BIGQUERY",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"bing_ads": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The report type. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"fields": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `The field names. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
									listvalidator.SizeAtLeast(1),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["BING_ADS"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"BING_ADS",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"blackline": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Blackline report name. Example: Account Details Extract Template. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["BLACKLINE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"BLACKLINE",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"braintree": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Braintree entity. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["BRAINTREE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"BRAINTREE",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"confluent_cloud": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `You can ingest data from Kafka topics in your Confluent Cloud cluster. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["CONFLUENT_CLOUD"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"CONFLUENT_CLOUD",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"coupa": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Coupa resource. Example: Approvals, Items, Suppliers. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["COUPA"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"COUPA",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"criteo": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"currency": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `currency` + "`" + ` if and only if the entity is 'report_placement', 'report_statistics' or 'report_transactions'. Example values: [USD, EUR]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
									listvalidator.SizeAtMost(1),
								},
							},
							"dimensions": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `dimension` + "`" + ` if and only if the entity is 'report_placement' or 'report_statistics'. Example values: [Day, advertiserId, adsetId]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Criteo resource. Example: ad_set, advertiser, audience, campaign, report_placement, report_statistics, and report_transactions. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"metrics": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `metric` + "`" + ` if and only if the entity is 'report_placement' or 'report_statistics'. Example values: [clicks, displays]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"timezone": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `timezone` + "`" + ` if and only if the entity is 'report_placement' or 'report_transactions'. Example values: [UTC, ETC/GMT-3]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
									listvalidator.SizeAtMost(1),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["CRITEO"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"CRITEO",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"db2": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["DB2"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"DB2",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"db2_sharded": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["DB2_SHARDED"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"DB2_SHARDED",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"delta_lake": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["DELTA_LAKE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"DELTA_LAKE",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"egnyte": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Excel resource path on egnyte. e.g. "/Shared/Documents/data.xlsx" or  "/Shared/Documents/data.xlsx/sheet_1". Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["EGNYTE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"EGNYTE",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"elasticsearch": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The index name. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["ELASTICSEARCH"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"ELASTICSEARCH",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"elluminate": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"domain_name": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `The Domain that you want to extract from. If no domain is specified Etleap will extract data from all schema's domains. . Requires replacement if changed. `,
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Elluminate study name. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"schema_name": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Schema that you want to extract from. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["ELLUMINATE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"ELLUMINATE",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"eloqua": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Eloqua resource, spelled as it is shown in the Eloqua UI. Each ActivityType is a different entity and is spelled without spaces like EmailClickthrough and EmailSend. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["ELOQUA"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"ELOQUA",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"erpx": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The ERPx resource. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["ERPX"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"ERPX",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"facebook_ads": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"breakdowns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `The breakdown fields. The first one must be ` + "`" + `date_start` + "`" + `. See the [Facebook Documentation on Breakdowns.](https://developers.facebook.com/docs/marketing-api/insights/breakdowns/v21.0#insights-api-breakdowns). Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
									listvalidator.SizeAtLeast(1),
								},
							},
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The aggregation level of the Facebook report. Example values: [Insights by Ad, Insights by Adset, Insights by Campaign, Insights by Account]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["FACEBOOK_ADS"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"FACEBOOK_ADS",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"fifteen_five": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The 15Five entity. Example values: [answer, report, department, feature-status, group-type, group, high-five, objective_objective_id_history, objective, attribute_value, attribute, priority, question, security-audit, vacation, user]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["FIFTEEN_FIVE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"FIFTEEN_FIVE",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"freshchat": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Freshchat resource. Example values: [Agents, Channels, Conversations, Conversation Messages]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["FRESHCHAT"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"FRESHCHAT",
									),
								},
							},
							"view": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Only when Entity is related to Deals. Select which views you want Etleap to pull data from. Requires replacement if changed. `,
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"freshsales": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Freshsales resource. Example values: [Leads, Deals, Appointments or Tasks]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["FRESHSALES"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"FRESHSALES",
									),
								},
							},
							"view": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Only when Entity is related to Deals. Select which views you want Etleap to pull data from. Requires replacement if changed. `,
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"freshworks": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["FRESHWORKS"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"FRESHWORKS",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"ftp": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"file_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching the names of the files to be processed by this pipeline. A single value for ` + "`" + `paths` + "`" + ` is required when ` + "`" + `fileNameFilter` + "`" + ` is specified. Requires replacement if changed. `,
							},
							"glob_pattern": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `A glob pattern to be used as a path. Either ` + "`" + `globPattern` + "`" + ` or ` + "`" + `paths` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"low_watermark": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Timestamp of the earliest modified file that should be processed by the pipeline. Only the files modified after this timestamp will be processed. Format of the timestamp: 'yyyy-MM-dd'. Requires replacement if changed. `,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"new_file_behavior": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Specifies whether new files update, add to or replace existing files. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjI0NTQwNzI2-create-a-file-based-pipeline#update-method">the documentation</a> for more details. Requires replacement if changed. ; Not Null; must be one of ["UPDATE", "APPEND", "REPLACE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"UPDATE",
										"APPEND",
										"REPLACE",
									),
								},
							},
							"paths": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `File or folder paths for the files to be extracted from the source. In the case when ` + "`" + `fileNameFilter` + "`" + ` is specified exactly one folder path must be given here. ` + "`" + `paths` + "`" + ` can't be used when a ` + "`" + `globPattern` + "`" + ` is specified. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["FTP"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"FTP",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"gong": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Gong resource. Example values: [Answered Scorecards, Call Transcripts, Calls, Calls Extensive, Folders, Interactions, Scorecards, Users, Users Activity, Users Extensive, Workspaces]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["GONG"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"GONG",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"google_ads": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"attributed_resources": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `attributed resources` + "`" + `. Example values: [campaign_budget.id, campaign_budget.name, bidding_strategy.type]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Google Ads report type, capitalized and spelled with spaces between words. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"fields": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `fields` + "`" + `. Example values: [campaign.resource_name, campaign.campaign_budget, campaign.advertising_channel_type]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"metrics": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `metrics` + "`" + `. Example values: [metrics.clicks, metrics.all_conversions, metrics.average_cost]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"segments": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `segmentation` + "`" + ` groups. Example values: [segments.date, segments.click_type, segments.geo_target_county]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["GOOGLE_ADS"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"GOOGLE_ADS",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"google_analytics_ga4": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"dimensions": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Dimensions are attributes for your data. Example values: [date, browser]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
									listvalidator.SizeAtLeast(1),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Google Analytics GA4 resource. Provide the ID of the GA4 resource. You can find out how to retrieve the ID of you resource <a href='https://developers.google.com/analytics/devguides/reporting/data/v1/property-id'>here</a>. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"metrics": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Metrics represent quantitative measurements calculated by Google Analytics. Example values: [active1DayUsers, conversions]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
									listvalidator.SizeAtLeast(1),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["GOOGLE_ANALYTICS_GA4"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"GOOGLE_ANALYTICS_GA4",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"google_cloud_storage": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"file_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching the names of the files to be processed by this pipeline. A single value for ` + "`" + `paths` + "`" + ` is required when ` + "`" + `fileNameFilter` + "`" + ` is specified. Requires replacement if changed. `,
							},
							"glob_pattern": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `A glob pattern to be used as a path. Either ` + "`" + `globPattern` + "`" + ` or ` + "`" + `paths` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"low_watermark": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Timestamp of the earliest modified file that should be processed by the pipeline. Only the files modified after this timestamp will be processed. Format of the timestamp: 'yyyy-MM-dd'. Requires replacement if changed. `,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"new_file_behavior": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Specifies whether new files update, add to or replace existing files. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjI0NTQwNzI2-create-a-file-based-pipeline#update-method">the documentation</a> for more details. Requires replacement if changed. ; Not Null; must be one of ["UPDATE", "APPEND", "REPLACE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"UPDATE",
										"APPEND",
										"REPLACE",
									),
								},
							},
							"paths": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `File or folder paths for the files to be extracted from the source. In the case when ` + "`" + `fileNameFilter` + "`" + ` is specified exactly one folder path must be given here. ` + "`" + `paths` + "`" + ` can't be used when a ` + "`" + `globPattern` + "`" + ` is specified. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["GOOGLE_CLOUD_STORAGE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"GOOGLE_CLOUD_STORAGE",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"google_sheets": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Google Sheets entities are in the form ` + "`" + `SpreadsheetID/SheetID` + "`" + `. You can find both values by clicking on the sheet (tab) you want and looking at the URL: docs.google.com/spreadsheets/d/` + "`" + `1pRAGMSRpEEG31kbtG2qcpr-HDeDfvafp_v00` + "`" + `/edit#gid=` + "`" + `642381756` + "`" + `. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["GOOGLE_SHEETS"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"GOOGLE_SHEETS",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"hubspot": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Hubspot entity. Example values: [Campaigns, Contacts, Email Events, Engagements, Deals, Owners, Deal Pipelines, Companies, Marketing Emails, Pages, Landing Pages Analytics]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["HUBSPOT"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"HUBSPOT",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"impact_radius": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Impact Radius entity, spelled the same way as in the UI. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["IMPACT_RADIUS"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"IMPACT_RADIUS",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"intercom": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Intercom entity. Example values: [User, Lead, Contact, Company, Admin, Tag, Segment, Note, Event, Counts, Conversation Counts, Admin Conversation Counts, User Tags Counts, User Segments Counts, Company Tags Counts, Company Segments Counts, Conversation, Conversation Parts, Conversation Tags, Subscription]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["INTERCOM"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"INTERCOM",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"jira": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The JIRA entity. Example values: [Issues, Issue Links, Issue Types, Changelog, Comments, Worklogs, Fields, Groups, Group Members, Priorities, Projects, Resolutions, Statuses, Status Categories, Users, Multiple Choice Field]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["JIRA"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"JIRA",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"jira_align": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The JIRA Align entity. Spelled without spaces except for the Audit Logs. Example values: [Capabilities, Cities, Customers, Defects, Epics, Epics Audit Logs, Features, Features Audit Logs, Goals, Ideas, Iterations, KeyResults, Milestones, Milestones Audit Logs, Objectives, Objectives Audit Logs, Portfolios, Products, Programs, Regions, ReleaseVehicles, Releases, Snapshots, Stories, Tasks, Teams, Themes, Users, ValueStreams]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["JIRA_ALIGN"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"JIRA_ALIGN",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"kafka": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `You can ingest data from Kafka topics. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["KAFKA"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"KAFKA",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"kustomer": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Kustomer entity. Example values: [AUDIT_LOGS, BRANDS, BUSINESS_SCHEDULES, CARDS, COMPANIES, CONVERSATION_ATTACHMENTS, CONVERSATION_EVENTS, CONVERSATION_FORWARDS, CONVERSATION_TIMES, CONVERSATIONS, CUSTOM_ATTRIBUTE_METADATA, CUSTOMER_DRAFTS, CUSTOMER_MERGES, CUSTOMERS, KOBJECTS, KLASSES, MESSAGES, NOTES, NOTIFICATIONS, OUTBOUND_ACCOUNTS, QUEUES, SLAS, SATISFACTIONS, SHORTCUTS, SNOOZES, SPAM_SENDERS, TEAM_ROUTING_SETTINGS, TEAMS, USERS]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["KUSTOMER"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"KUSTOMER",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"ldap": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["LDAP"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"LDAP",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"ldap_virtual_list_view": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["LDAP_VIRTUAL_LIST_VIEW"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"LDAP_VIRTUAL_LIST_VIEW",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"linked_in_ads": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The LinkedIn resource. Example values: [ACCOUNTS, ACCOUNT_USERS, AD_ANALYTICS, CAMPAIGNS, CAMPAIGN_GROUPS, CONVERSIONS, INSIGHT_TAG_DOMAINS]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"metrics": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `metrics` + "`" + ` if and only if the entity is 'AD_ANALYTICS'. Example values: [dateRange, pivotValues, clicks]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"pivots": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `pivots` + "`" + ` groups if and only if the entity is 'AD_ANALYTICS'. Example values: [ACCOUNT, CAMPAIGN, COMPANY]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["LINKED_IN_ADS"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"LINKED_IN_ADS",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"marketo": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"activity_types": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify ` + "`" + `activityTypes` + "`" + ` if and only if the entity is 'Activities'. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Marketo entity type. Example values: [Leads, Activities, Campaigns, Programs, Tags]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["MARKETO"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"MARKETO",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"mixpanel": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `'Raw Data' is the only entity available for Mixpanel. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["MIXPANEL"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"MIXPANEL",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"mongodb": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["MONGODB"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"MONGODB",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"mysql": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"database": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the database in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["MYSQL"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"MYSQL",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"mysql_sharded": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"database": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the database in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["MYSQL_SHARDED"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"MYSQL_SHARDED",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"netsuite": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Netsuite entity. Spelled capitalized without spaces unless you have defined a custom entity in Netsuite with a different capitalization. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["NETSUITE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"NETSUITE",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"netsuite_v2": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Netsuite entity. Spelled capitalized with spaces. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["NETSUITE_V2"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"NETSUITE_V2",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"oracle": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["ORACLE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"ORACLE",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"oracle_sharded": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["ORACLE_SHARDED"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"ORACLE_SHARDED",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"outlook": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Outlook entity. Example values: [Messages, Events]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["OUTLOOK"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"OUTLOOK",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"outreach": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["OUTREACH"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"OUTREACH",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"pinterest_ads": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `metrics` + "`" + ` if and only if the entity is 'reports'. Example values: [SPEND_IN_MICRO_DOLLAR, PAID_IMPRESSION, CPC_IN_MICRO_DOLLAR]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Pinterest Ads resource. Example values: [ad_accounts, ad_groups, ads, campaigns and reports]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"level": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `data level` + "`" + ` if and only if the entity is 'reports'. Example values: [ADVERTISER, CAMPAIGN, AD_GROUP]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"targeting_types": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `targeting types` + "`" + ` if and only if the entity is 'reports'. Example values: [KEYWORD, APPTYPE, LOCATION]. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["PINTEREST_ADS"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"PINTEREST_ADS",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"postgres": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["POSTGRES"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"POSTGRES",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"postgres_sharded": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["POSTGRES_SHARDED"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"POSTGRES_SHARDED",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"quora_ads": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The level of aggregation for your Quora Ads data. Example values: [Account, Campaign, Ad Set, Ad]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["QUORA_ADS"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"QUORA_ADS",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"rave_medidata": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Rave Medidata entity. Example values: [dataset, study, <study-oid>@-@<form-oid>]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["RAVE_MEDIDATA"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"RAVE_MEDIDATA",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"recurly": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Recurly entity. Example values: [Account, Account Acquisition, Line Item, Coupon, Coupon Redemption, Credit Payment, Invoice, Measured Unit, Plan, Plan Add-On, Subscription, Transaction]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["RECURLY"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"RECURLY",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"redshift": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["REDSHIFT"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"REDSHIFT",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"redshift_sharded": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["REDSHIFT_SHARDED"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"REDSHIFT_SHARDED",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"s3_input": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"file_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching the names of the files to be processed by this pipeline. A single value for ` + "`" + `paths` + "`" + ` is required when ` + "`" + `fileNameFilter` + "`" + ` is specified. Requires replacement if changed. `,
							},
							"files_can_change": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Etleap can check whether files that were already processed have changed. If the file has changed, then Etleap fetches the new file and removes the old file's data in the destination and adds the changed data. <br> This can only be enabled when ` + "`" + `newFileBehavior` + "`" + ` is set to ` + "`" + `APPEND` + "`" + `. Defaults to ` + "`" + `false` + "`" + `. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"low_watermark": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Timestamp of the earliest modified file that should be processed by the pipeline. Only the files modified after this timestamp will be processed. Format of the timestamp: 'yyyy-MM-dd'. Requires replacement if changed. `,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"new_file_behavior": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Specifies whether new files update, add to or replace existing files. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjI0NTQwNzI2-create-a-file-based-pipeline#update-method">the documentation</a> for more details. Requires replacement if changed. ; Not Null; must be one of ["UPDATE", "APPEND", "REPLACE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"UPDATE",
										"APPEND",
										"REPLACE",
									),
								},
							},
							"paths": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `File or folder paths for the files to be extracted from the source. In the case when ` + "`" + `fileNameFilter` + "`" + ` is specified exactly one folder path must be given here. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
									listvalidator.SizeAtLeast(1),
								},
							},
							"triggered_by_event": schema.BoolAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Bool{
									boolplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Whether this source should be triggered by a ` + "`" + `Batch Added` + "`" + ` event (` + "`" + `true` + "`" + `) or Etleap should inspect the source to find new files to process (` + "`" + `false` + "`" + `). Defaults to ` + "`" + `false` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["S3_INPUT"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"S3_INPUT",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"s3_legacy": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"file_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching the names of the files to be processed by this pipeline. A single value for ` + "`" + `paths` + "`" + ` is required when ` + "`" + `fileNameFilter` + "`" + ` is specified. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"low_watermark": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Timestamp of the earliest modified file that should be processed by the pipeline. Only the files modified after this timestamp will be processed. Format of the timestamp: 'yyyy-MM-dd'. Requires replacement if changed. `,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"new_file_behavior": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Specifies whether new files update, add to or replace existing files. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjI0NTQwNzI2-create-a-file-based-pipeline#update-method">the documentation</a> for more details. Requires replacement if changed. ; Not Null; must be one of ["UPDATE", "APPEND", "REPLACE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"UPDATE",
										"APPEND",
										"REPLACE",
									),
								},
							},
							"paths": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `File or folder paths for the files to be extracted from the source. In the case when ` + "`" + `fileNameFilter` + "`" + ` is specified exactly one folder path must be given here. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
									listvalidator.SizeAtLeast(1),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["S3_LEGACY"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"S3_LEGACY",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"salesforce": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Salesforce table. Spelled capitalized without spaces, unless it is a custom table like ` + "`" + `My_Table__c` + "`" + `. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SALESFORCE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SALESFORCE",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"salesforce_marketing_cloud": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Salesforce Marketing Cloud entity. Example Values: [Bounce Event, Campaign, Click Event, Content Area, Data Extension, Data Extension Object, Email, Folders, List Subscriber, Lists, Open Event, Send, Sent Event, Subscribers, Unsub Event]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SALESFORCE_MARKETING_CLOUD"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SALESFORCE_MARKETING_CLOUD",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"sap_concur": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The SAP Concur entity. Example Values: [ExpenseEntries, Reports, Users]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SAP_CONCUR"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SAP_CONCUR",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"sap_hana": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SAP_HANA"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SAP_HANA",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"sap_hana_sharded": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SAP_HANA_SHARDED"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SAP_HANA_SHARDED",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"seismic": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Seismic entity. Example values: [Livesend Links, Livesend Link Contents, Livesend Link Members, Livesend Page Views, Users, User Activity]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SEISMIC"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SEISMIC",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"service_now": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The ServiceNow entity. Example values: [Task, Problem, Incident]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SERVICE_NOW"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SERVICE_NOW",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"sftp": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"file_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching the names of the files to be processed by this pipeline. A single value for ` + "`" + `paths` + "`" + ` is required when ` + "`" + `fileNameFilter` + "`" + ` is specified. Requires replacement if changed. `,
							},
							"glob_pattern": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `A glob pattern to be used as a path. Either ` + "`" + `globPattern` + "`" + ` or ` + "`" + `paths` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"low_watermark": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Timestamp of the earliest modified file that should be processed by the pipeline. Only the files modified after this timestamp will be processed. Format of the timestamp: 'yyyy-MM-dd'. Requires replacement if changed. `,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"new_file_behavior": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Specifies whether new files update, add to or replace existing files. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjI0NTQwNzI2-create-a-file-based-pipeline#update-method">the documentation</a> for more details. Requires replacement if changed. ; Not Null; must be one of ["UPDATE", "APPEND", "REPLACE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"UPDATE",
										"APPEND",
										"REPLACE",
									),
								},
							},
							"paths": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `File or folder paths for the files to be extracted from the source. In the case when ` + "`" + `fileNameFilter` + "`" + ` is specified exactly one folder path must be given here. ` + "`" + `paths` + "`" + ` can't be used when a ` + "`" + `globPattern` + "`" + ` is specified. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SFTP"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SFTP",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"shopify": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Shopify entity. Spelled with spaces and only first word capitalized. Nested JSON objects are selected by appending the field name. For example, ` + "`" + `Orders fulfillments line items` + "`" + ` has the lineItems field from the ` + "`" + `Order fulfillments` + "`" + ` entity. Start creating a pipeline in the Etleap UI for the full list of entities. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SHOPIFY"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SHOPIFY",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"skyward": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Skyward entity. Spelled capitalized with spaces. Example Values: [Academic Sessions, Categories, Classes, Courses, Demographics, Enrollments, Grading Periods, Line Items, Orgs, Results, Schools, Students, Teachers, Terms, Users]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SKYWARD"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SKYWARD",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"snapchat_ads": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"additional_metrics": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `additional metrics` + "`" + ` if and only if the entity is 'ad_account_report_hourly' or 'ad_account_report_daily'. Example values: [android_installs, attachment_avg_view_time_millis, attachment_frequency]. Requires replacement if changed. `,
							},
							"breakdown": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Specify the report ` + "`" + `breakdown` + "`" + ` if and only if the entity is 'ad_account_report_hourly' or 'ad_account_report_daily'. Example values: [ad, adsquad, campaign]. Requires replacement if changed. `,
							},
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Snapchat Ads entity. Example values: [ad, adaccount, ad_account_report_hourly, ad_account_report_daily]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"metrics": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `metrics` + "`" + ` if and only if the entity is 'ad_account_report_hourly' or 'ad_account_report_daily'. Example values: [impressions, swipes, screen_time_millis]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"report_dimension": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `dimension` + "`" + ` groups if and only if the entity is 'ad_account_report_hourly' or 'ad_account_report_daily'. Example values: [country, region, gender]. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SNAPCHAT_ADS"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SNAPCHAT_ADS",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"snowflake": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["ACTIVE_CAMPAIGN", "BIGQUERY", "BING_ADS", "BLACKLINE", "BRAINTREE", "CONFLUENT_CLOUD", "COUPA", "CRITEO", "DB2", "DB2_SHARDED", "DELTA_LAKE", "EGNYTE", "ELASTICSEARCH", "ELLUMINATE", "ELOQUA", "ERPX", "FACEBOOK_ADS", "FIFTEEN_FIVE", "FRESHCHAT", "FRESHSALES", "FRESHWORKS", "FTP", "GONG", "GOOGLE_ANALYTICS_GA4", "GOOGLE_CLOUD_STORAGE", "GOOGLE_ADS", "GOOGLE_SHEETS", "HUBSPOT", "INTERCOM", "IMPACT_RADIUS", "JIRA", "JIRA_ALIGN", "KAFKA", "KUSTOMER", "LDAP", "LDAP_VIRTUAL_LIST_VIEW", "LINKED_IN_ADS", "MARKETO", "MIXPANEL", "MONGODB", "MYSQL", "MYSQL_SHARDED", "NETSUITE", "NETSUITE_V2", "ORACLE", "ORACLE_SHARDED", "OUTREACH", "OUTLOOK", "PINTEREST_ADS", "POSTGRES", "POSTGRES_SHARDED", "QUORA_ADS", "RAVE_MEDIDATA", "RECURLY", "REDSHIFT", "REDSHIFT_SHARDED", "S3_LEGACY", "S3_INPUT", "S3_DATA_LAKE", "SALESFORCE_MARKETING_CLOUD", "SAP_CONCUR", "SAP_HANA", "SAP_HANA_SHARDED", "SEISMIC", "SERVICE_NOW", "SHOPIFY", "SKYWARD", "SALESFORCE", "SFTP", "SQL_SERVER", "SQL_SERVER_SHARDED", "STREAMING", "SNOWFLAKE", "SNOWFLAKE_SHARDED", "SQUARE", "SNAPCHAT_ADS", "STRIPE", "SUMTOTAL", "THE_TRADE_DESK", "TIK_TOK_ADS", "TWILIO", "TWITTER_ADS", "USER_DEFINED_API", "USERVOICE", "VEEVA", "VERIZON_MEDIA_DSP", "WORKDAY_REPORT", "WORKFRONT", "ZENDESK", "ZOOM_PHONE", "ZUORA"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"ACTIVE_CAMPAIGN",
										"BIGQUERY",
										"BING_ADS",
										"BLACKLINE",
										"BRAINTREE",
										"CONFLUENT_CLOUD",
										"COUPA",
										"CRITEO",
										"DB2",
										"DB2_SHARDED",
										"DELTA_LAKE",
										"EGNYTE",
										"ELASTICSEARCH",
										"ELLUMINATE",
										"ELOQUA",
										"ERPX",
										"FACEBOOK_ADS",
										"FIFTEEN_FIVE",
										"FRESHCHAT",
										"FRESHSALES",
										"FRESHWORKS",
										"FTP",
										"GONG",
										"GOOGLE_ANALYTICS_GA4",
										"GOOGLE_CLOUD_STORAGE",
										"GOOGLE_ADS",
										"GOOGLE_SHEETS",
										"HUBSPOT",
										"INTERCOM",
										"IMPACT_RADIUS",
										"JIRA",
										"JIRA_ALIGN",
										"KAFKA",
										"KUSTOMER",
										"LDAP",
										"LDAP_VIRTUAL_LIST_VIEW",
										"LINKED_IN_ADS",
										"MARKETO",
										"MIXPANEL",
										"MONGODB",
										"MYSQL",
										"MYSQL_SHARDED",
										"NETSUITE",
										"NETSUITE_V2",
										"ORACLE",
										"ORACLE_SHARDED",
										"OUTREACH",
										"OUTLOOK",
										"PINTEREST_ADS",
										"POSTGRES",
										"POSTGRES_SHARDED",
										"QUORA_ADS",
										"RAVE_MEDIDATA",
										"RECURLY",
										"REDSHIFT",
										"REDSHIFT_SHARDED",
										"S3_LEGACY",
										"S3_INPUT",
										"S3_DATA_LAKE",
										"SALESFORCE_MARKETING_CLOUD",
										"SAP_CONCUR",
										"SAP_HANA",
										"SAP_HANA_SHARDED",
										"SEISMIC",
										"SERVICE_NOW",
										"SHOPIFY",
										"SKYWARD",
										"SALESFORCE",
										"SFTP",
										"SQL_SERVER",
										"SQL_SERVER_SHARDED",
										"STREAMING",
										"SNOWFLAKE",
										"SNOWFLAKE_SHARDED",
										"SQUARE",
										"SNAPCHAT_ADS",
										"STRIPE",
										"SUMTOTAL",
										"THE_TRADE_DESK",
										"TIK_TOK_ADS",
										"TWILIO",
										"TWITTER_ADS",
										"USER_DEFINED_API",
										"USERVOICE",
										"VEEVA",
										"VERIZON_MEDIA_DSP",
										"WORKDAY_REPORT",
										"WORKFRONT",
										"ZENDESK",
										"ZOOM_PHONE",
										"ZUORA",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"snowflake_sharded": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SNOWFLAKE_SHARDED"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SNOWFLAKE_SHARDED",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"sql_server": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SQL_SERVER"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SQL_SERVER",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"sql_server_sharded": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"last_updated_column": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of a column that indicates the time the record was updated at the source. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"primary_key_columns": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Columns that make up the primary key of the source. The specified order of columns matters for composite primary keys. <br> For source tables that do not have primary keys please specify an empty array. <br> For sharded sources include ` + "`" + `shard_id` + "`" + ` as first primary key column.<br><br>The **default value** is an empty array. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
								},
							},
							"schema": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the schema in the source from which the data is to be extracted. If not specified, the source connection schema or the default schema for connection type will be used. Requires replacement if changed. `,
							},
							"table": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Name of the table to be extracted from the source. Either ` + "`" + `table` + "`" + ` or ` + "`" + `tableNameFilter` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"table_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching all partitions of a table. Partitions must have the same table schema. Either ` + "`" + `tableNameFilter` + "`" + ` or ` + "`" + `table` + "`" + ` must be specified, but not both. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SQL_SERVER_SHARDED"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SQL_SERVER_SHARDED",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"square": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Square entity. Example values: [Catalog, Customers, Loyalty Accounts, Loyalty Events, Loyalty Rewards, Orders, Refunds]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SQUARE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SQUARE",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"streaming": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"file_name_filter": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Regular expression matching the names of the files to be processed by this pipeline. A single value for ` + "`" + `paths` + "`" + ` is required when ` + "`" + `fileNameFilter` + "`" + ` is specified. Requires replacement if changed. `,
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"low_watermark": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Timestamp of the earliest modified file that should be processed by the pipeline. Only the files modified after this timestamp will be processed. Format of the timestamp: 'yyyy-MM-dd'. Requires replacement if changed. `,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"new_file_behavior": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Specifies whether new files update, add to or replace existing files. See <a target="_blank" href="https://docs.etleap.com/docs/documentation/ZG9jOjI0NTQwNzI2-create-a-file-based-pipeline#update-method">the documentation</a> for more details. Requires replacement if changed. ; Not Null; must be one of ["UPDATE", "APPEND", "REPLACE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"UPDATE",
										"APPEND",
										"REPLACE",
									),
								},
							},
							"paths": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `File or folder paths for the files to be extracted from the source. In the case when ` + "`" + `fileNameFilter` + "`" + ` is specified exactly one folder path must be given here. Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
									listvalidator.SizeAtLeast(1),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["STREAMING"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"STREAMING",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"stripe": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Stripe entity. Example values: [Subscriptions, Invoice, InvoiceItems, Events]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["STRIPE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"STRIPE",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"sumtotal": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The SumTotal entity. Example values: [Activities, Audiences, Competencies, Domains, Grades, Jobs, Organizations, Skills, Social, Topics, User Activities, User Activities Progress, User Courses, Users]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["SUMTOTAL"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"SUMTOTAL",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"the_trade_desk": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["THE_TRADE_DESK"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"THE_TRADE_DESK",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"tik_tok_ads": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"data_level": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Specify the report ` + "`" + `data level` + "`" + ` if and only if the entity is 'REPORT'. Example values: [AUCTION_AD, AUCTION_CAMPAIGN, RESERVATION_AD]. Requires replacement if changed. `,
							},
							"dimensions": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `dimension` + "`" + ` groups if and only if the entity is 'REPORT'. Example values: [start_time_day, start_time_hour, campaign_id]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The TikTok Ads resource. Example values: [AD, ADGROUP, ADVERTISER, CAMPAIGN and REPORT]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"metrics": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Specify the report ` + "`" + `metrics` + "`" + ` if and only if the entity is 'REPORT'. Example values: [ad_name, clicks, conversion]. Requires replacement if changed. `,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["TIK_TOK_ADS"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"TIK_TOK_ADS",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"twilio": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Twilio entity. Example values: [Calls, Calls summary, Messages, Usage records]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["TWILIO"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"TWILIO",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"twitter_ads": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Twitter entity. Example values: [Account, Campaign, Funding Instrument, Line Item, Media Creative, Promoted Tweet, Followers, Tweets Likes, Tweets Quotes, Retweets, Recent Mentions,Tweets, Account Report, Campaign Report, Funding Instrument Report, Line Item Report, Media Creative Report, Promoted Tweet Report]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["TWITTER_ADS"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"TWITTER_ADS",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"user_defined_api": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The User-Defined API entity. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["USER_DEFINED_API"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"USER_DEFINED_API",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"uservoice": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The UserVoice entity. Example values: [Category, Comment, Feature, Feature Status, Feedback Record, Forum, Forum Invitation, Internal Status, Label, NPS Rating, Note, Permission, Product Area, Score, Segment, Segmented Values, Status, Status Updates, Suggestion, Suggestion Activity Entry, Supporter, Supporter Message, Team, User, VSTS Work Item]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["USERVOICE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"USERVOICE",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"veeva": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Veeva Entity name. Example values: [APQR, APQR Item, Action, Activity, Admin Link, Admin Section, Admin Section Controller Code, Answer Library Design, Application Context Selector, Application License Model, Application License Model Field, Application Manifest, Application Provisioner, Application Role]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["VEEVA"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"VEEVA",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"verizon_media_dsp": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"dimensions": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
									listvalidator.SizeAtLeast(1),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"metrics": schema.ListAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								ElementType: types.StringType,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
									listvalidator.SizeAtLeast(1),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["VERIZON_MEDIA_DSP"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"VERIZON_MEDIA_DSP",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"workday_report": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Workday Report name. Spelled the same as Workday UI but all spaces are replaced with underscores. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["WORKDAY_REPORT"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"WORKDAY_REPORT",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"workfront": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Workfront entity. Spelled capitalized without spaces. For the full list, start creating a pipeline in the Etleap UI. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["WORKFRONT"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"WORKFRONT",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"zendesk": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Zendesk entity. Example values: [Group Memberships, Groups, Macros, Organizations, Satisfaction Ratings, SLA Policies, Tags, Ticket Audits, Ticket Comments, Ticket Fields, Ticket Forms, Tickets, Ticket Metrics, Users]. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["ZENDESK"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"ZENDESK",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"zoom_phone": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["ZOOM_PHONE"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"ZOOM_PHONE",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"zuora": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The universally unique identifier for the source. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"entity": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The Zuora entity. Spelled capitalized with spaces. For the full list, start creating a pipeline in the Etleap UI. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"latency_threshold": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									int64planmodifier.RequiresReplaceIfConfigured(),
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Notify if we can't extract for ` + "`" + `x` + "`" + ` hours. Setting it to ` + "`" + `null` + "`" + ` disables the notification. Defaults to ` + "`" + `null` + "`" + `. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["ZUORA"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"ZUORA",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Requires replacement if changed. `,
				Validators: []validator.Object{
					validators.ExactlyOneChild(),
				},
			},
			"stop_reason": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Describes the reason a pipeline has stopped. ` + "`" + `null` + "`" + ` if the pipeline is currently running. If a pipeline is being refreshed, the stop reason will be for the refreshing pipeline. must be one of ["PAUSED", "PARSING_ERRORS", "SCHEMA_CHANGES", "REDSHIFT_RESIZE", "REDSHIFT_MAINTENANCE", "SOURCE_CONNECTION_DOWN", "DESTINATION_CONNECTION_DOWN", "PERMANENTLY_STOPPED", "SOURCE_BROKEN", "QUOTA_REACHED", "SOURCE_INACTIVE", "DESTINATION_INACTIVE", "PIPELINE_MODE_CHANGE"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"PAUSED",
						"PARSING_ERRORS",
						"SCHEMA_CHANGES",
						"REDSHIFT_RESIZE",
						"REDSHIFT_MAINTENANCE",
						"SOURCE_CONNECTION_DOWN",
						"DESTINATION_CONNECTION_DOWN",
						"PERMANENTLY_STOPPED",
						"SOURCE_BROKEN",
						"QUOTA_REACHED",
						"SOURCE_INACTIVE",
						"DESTINATION_INACTIVE",
						"PIPELINE_MODE_CHANGE",
					),
				},
			},
			"update_schedule": schema.SingleNestedAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.Object{
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"daily": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"hour_of_day": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Description: `Hour of day the  pipeline update should be started at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `must be one of ["DAILY"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"DAILY",
									),
								},
							},
						},
						Description: `The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.`,
					},
					"hourly": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"mode": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `must be one of ["HOURLY"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"HOURLY",
									),
								},
							},
						},
						Description: `The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.`,
					},
					"interval": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"interval_minutes": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Description: `Time to wait before new data is pulled (in minutes).`,
							},
							"mode": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `must be one of ["INTERVAL"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"INTERVAL",
									),
								},
							},
						},
						Description: `The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.`,
					},
					"monthly": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"day_of_month": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
							},
							"hour_of_day": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Description: `Hour of day the  pipeline update should be started at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `must be one of ["MONTHLY"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"MONTHLY",
									),
								},
							},
						},
						Description: `The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.`,
					},
					"weekly": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"day_of_week": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
							},
							"hour_of_day": schema.Int64Attribute{
								Computed: true,
								PlanModifiers: []planmodifier.Int64{
									speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
								},
								Description: `Hour of day the  pipeline update should be started at (in UTC).`,
							},
							"mode": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `must be one of ["WEEKLY"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"WEEKLY",
									),
								},
							},
						},
						Description: `The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information.`,
					},
				},
				Description: `The update schedule defines when Etleap should automatically check the source for new data. See <a href= "https://support.etleap.com/hc/en-us/articles/360019768853-What-is-the-difference-between-a-Refresh-and-an-Update-" target="_blank" rel="noopener">Updates &amp; Refreshes</a> for more information. When undefined, the pipeline will default to the schedule set on the source connection.`,
				Validators: []validator.Object{
					validators.ExactlyOneChild(),
				},
			},
		},
	}
}

func (r *PipelineResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.SDK)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.SDK, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *PipelineResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *PipelineResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request := *data.ToSharedPipelineInput()
	res, err := r.client.Pipeline.Create(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.PipelineOutput == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedPipelineOutput(res.PipelineOutput)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)
	id := data.ID.ValueString()
	request1 := operations.GetPipelineRequest{
		ID: id,
	}
	res1, err := r.client.Pipeline.Get(ctx, request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if res1.PipelineOutput == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res1.RawResponse))
		return
	}
	data.RefreshFromSharedPipelineOutput(res1.PipelineOutput)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *PipelineResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *PipelineResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	id := data.ID.ValueString()
	request := operations.GetPipelineRequest{
		ID: id,
	}
	res, err := r.client.Pipeline.Get(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.PipelineOutput == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedPipelineOutput(res.PipelineOutput)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *PipelineResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *PipelineResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	id := data.ID.ValueString()
	pipelineUpdate := *data.ToSharedPipelineUpdate()
	request := operations.UpdatePipelineRequest{
		ID:             id,
		PipelineUpdate: pipelineUpdate,
	}
	res, err := r.client.Pipeline.Update(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.PipelineOutput == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedPipelineOutput(res.PipelineOutput)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)
	id1 := data.ID.ValueString()
	request1 := operations.GetPipelineRequest{
		ID: id1,
	}
	res1, err := r.client.Pipeline.Get(ctx, request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if res1.PipelineOutput == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res1.RawResponse))
		return
	}
	data.RefreshFromSharedPipelineOutput(res1.PipelineOutput)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *PipelineResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *PipelineResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	id := data.ID.ValueString()
	pipelineDelete := data.ToSharedPipelineDelete()
	request := operations.DeletePipelineRequest{
		ID:             id,
		PipelineDelete: pipelineDelete,
	}
	res, err := r.client.Pipeline.Delete(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 204 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *PipelineResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
}
